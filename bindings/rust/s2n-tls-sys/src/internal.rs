/* automatically generated by rust-bindgen 0.58.1 */


// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0


#![allow(unused_imports, non_camel_case_types, non_snake_case, non_upper_case_globals)]

use libc::{iovec, FILE};

use libc::{pid_t as __pid_t, c_int as __sig_atomic_t};

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub type pid_t = __pid_t;
extern "C" {
    #[doc = " Returns the address of the thread-local `s2n_errno` variable"]
    #[doc = ""]
    #[doc = " This function can be used instead of trying to resolve `s2n_errno` directly"]
    #[doc = " in runtimes where thread-local variables may not be easily accessible."]
    pub fn s2n_errno_location() -> *mut ::libc::c_int;
}
pub mod s2n_error_type {
    pub type Type = ::libc::c_uint;
    pub const S2N_ERR_T_OK: Type = 0;
    pub const S2N_ERR_T_IO: Type = 1;
    pub const S2N_ERR_T_CLOSED: Type = 2;
    pub const S2N_ERR_T_BLOCKED: Type = 3;
    pub const S2N_ERR_T_ALERT: Type = 4;
    pub const S2N_ERR_T_PROTO: Type = 5;
    pub const S2N_ERR_T_INTERNAL: Type = 6;
    pub const S2N_ERR_T_USAGE: Type = 7;
}
extern "C" {
    pub fn s2n_error_get_type(error: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_get_openssl_version() -> ::libc::c_ulong;
}
extern "C" {
    pub fn s2n_init() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cleanup() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_new() -> *mut s2n_config;
}
extern "C" {
    pub fn s2n_config_free(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_free_dhparams(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_free_cert_chain_and_key(config: *mut s2n_config) -> ::libc::c_int;
}
pub type s2n_clock_time_nanoseconds = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *mut u64) -> ::libc::c_int,
>;
pub type s2n_cache_retrieve_callback = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        arg1: *mut ::libc::c_void,
        key: *const ::libc::c_void,
        key_size: u64,
        value: *mut ::libc::c_void,
        value_size: *mut u64,
    ) -> ::libc::c_int,
>;
pub type s2n_cache_store_callback = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        arg1: *mut ::libc::c_void,
        ttl_in_seconds: u64,
        key: *const ::libc::c_void,
        key_size: u64,
        value: *const ::libc::c_void,
        value_size: u64,
    ) -> ::libc::c_int,
>;
pub type s2n_cache_delete_callback = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        arg1: *mut ::libc::c_void,
        key: *const ::libc::c_void,
        key_size: u64,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_config_set_wall_clock(
        config: *mut s2n_config,
        clock_fn: s2n_clock_time_nanoseconds,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_monotonic_clock(
        config: *mut s2n_config,
        clock_fn: s2n_clock_time_nanoseconds,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_strerror(error: ::libc::c_int, lang: *const ::libc::c_char)
        -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_strerror_debug(
        error: ::libc::c_int,
        lang: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_strerror_name(error: ::libc::c_int) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_stack_traces_enabled() -> bool;
}
extern "C" {
    pub fn s2n_stack_traces_enabled_set(newval: bool) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_calculate_stacktrace() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_print_stacktrace(fptr: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_free_stacktrace() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_get_stacktrace(trace: *mut s2n_stacktrace) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cache_store_callback(
        config: *mut s2n_config,
        cache_store_callback: s2n_cache_store_callback,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cache_retrieve_callback(
        config: *mut s2n_config,
        cache_retrieve_callback: s2n_cache_retrieve_callback,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cache_delete_callback(
        config: *mut s2n_config,
        cache_delete_callback: s2n_cache_delete_callback,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
pub type s2n_mem_init_callback = ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
pub type s2n_mem_cleanup_callback = ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
pub type s2n_mem_malloc_callback = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut *mut ::libc::c_void,
        requested: u32,
        allocated: *mut u32,
    ) -> ::libc::c_int,
>;
pub type s2n_mem_free_callback = ::core::option::Option<
    unsafe extern "C" fn(ptr: *mut ::libc::c_void, size: u32) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_mem_set_callbacks(
        mem_init_callback: s2n_mem_init_callback,
        mem_cleanup_callback: s2n_mem_cleanup_callback,
        mem_malloc_callback: s2n_mem_malloc_callback,
        mem_free_callback: s2n_mem_free_callback,
    ) -> ::libc::c_int;
}
pub type s2n_rand_init_callback = ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
pub type s2n_rand_cleanup_callback =
    ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
pub type s2n_rand_seed_callback = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::libc::c_void, size: u32) -> ::libc::c_int,
>;
pub type s2n_rand_mix_callback = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::libc::c_void, size: u32) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_rand_set_callbacks(
        rand_init_callback: s2n_rand_init_callback,
        rand_cleanup_callback: s2n_rand_cleanup_callback,
        rand_seed_callback: s2n_rand_seed_callback,
        rand_mix_callback: s2n_rand_mix_callback,
    ) -> ::libc::c_int;
}
pub mod s2n_tls_extension_type {
    pub type Type = ::libc::c_uint;
    pub const S2N_EXTENSION_SERVER_NAME: Type = 0;
    pub const S2N_EXTENSION_MAX_FRAG_LEN: Type = 1;
    pub const S2N_EXTENSION_OCSP_STAPLING: Type = 5;
    pub const S2N_EXTENSION_SUPPORTED_GROUPS: Type = 10;
    pub const S2N_EXTENSION_EC_POINT_FORMATS: Type = 11;
    pub const S2N_EXTENSION_SIGNATURE_ALGORITHMS: Type = 13;
    pub const S2N_EXTENSION_ALPN: Type = 16;
    pub const S2N_EXTENSION_CERTIFICATE_TRANSPARENCY: Type = 18;
    pub const S2N_EXTENSION_RENEGOTIATION_INFO: Type = 65281;
}
pub mod s2n_max_frag_len {
    pub type Type = ::libc::c_uint;
    pub const S2N_TLS_MAX_FRAG_LEN_512: Type = 1;
    pub const S2N_TLS_MAX_FRAG_LEN_1024: Type = 2;
    pub const S2N_TLS_MAX_FRAG_LEN_2048: Type = 3;
    pub const S2N_TLS_MAX_FRAG_LEN_4096: Type = 4;
}
pub type s2n_cert_public_key = s2n_pkey;
pub type s2n_cert_private_key = s2n_pkey;
extern "C" {
    pub fn s2n_cert_chain_and_key_new() -> *mut s2n_cert_chain_and_key;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_load_pem(
        chain_and_key: *mut s2n_cert_chain_and_key,
        chain_pem: *const ::libc::c_char,
        private_key_pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_free(cert_and_key: *mut s2n_cert_chain_and_key) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_set_ctx(
        cert_and_key: *mut s2n_cert_chain_and_key,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_get_ctx(
        cert_and_key: *mut s2n_cert_chain_and_key,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_get_private_key(
        cert_and_key: *mut s2n_cert_chain_and_key,
    ) -> *mut s2n_cert_private_key;
}
pub type s2n_cert_tiebreak_callback = ::core::option::Option<
    unsafe extern "C" fn(
        cert1: *mut s2n_cert_chain_and_key,
        cert2: *mut s2n_cert_chain_and_key,
        name: *mut u8,
        name_len: u32,
    ) -> *mut s2n_cert_chain_and_key,
>;
extern "C" {
    pub fn s2n_config_set_cert_tiebreak_callback(
        config: *mut s2n_config,
        cert_tiebreak_cb: s2n_cert_tiebreak_callback,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_cert_chain_and_key(
        config: *mut s2n_config,
        cert_chain_pem: *const ::libc::c_char,
        private_key_pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_cert_chain_and_key_to_store(
        config: *mut s2n_config,
        cert_key_pair: *mut s2n_cert_chain_and_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cert_chain_and_key_defaults(
        config: *mut s2n_config,
        cert_key_pairs: *mut *mut s2n_cert_chain_and_key,
        num_cert_key_pairs: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_verification_ca_location(
        config: *mut s2n_config,
        ca_pem_filename: *const ::libc::c_char,
        ca_dir: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_pem_to_trust_store(
        config: *mut s2n_config,
        pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
pub type s2n_verify_host_fn = ::core::option::Option<
    unsafe extern "C" fn(
        host_name: *const ::libc::c_char,
        host_name_len: usize,
        data: *mut ::libc::c_void,
    ) -> u8,
>;
extern "C" {
    pub fn s2n_config_set_verify_host_callback(
        config: *mut s2n_config,
        arg1: s2n_verify_host_fn,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_check_stapled_ocsp_response(
        config: *mut s2n_config,
        check_ocsp: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_disable_x509_verification(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_max_cert_chain_depth(
        config: *mut s2n_config,
        max_depth: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_dhparams(
        config: *mut s2n_config,
        dhparams_pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cipher_preferences(
        config: *mut s2n_config,
        version: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Appends the provided application protocol to the preference list"]
    #[doc = ""]
    #[doc = " The data provided in `protocol` parameter will be copied into an internal buffer"]
    #[doc = ""]
    #[doc = " @param config The configuration object being updated"]
    #[doc = " @param protocol A pointer to a byte array value"]
    #[doc = " @param protocol_len The length of bytes that should be read from `protocol`. Note: this value cannot be 0, otherwise an error will be returned."]
    pub fn s2n_config_append_protocol_preference(
        config: *mut s2n_config,
        protocol: *const u8,
        protocol_len: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_protocol_preferences(
        config: *mut s2n_config,
        protocols: *const *const ::libc::c_char,
        protocol_count: ::libc::c_int,
    ) -> ::libc::c_int;
}
pub mod s2n_status_request_type {
    pub type Type = ::libc::c_uint;
    pub const S2N_STATUS_REQUEST_NONE: Type = 0;
    pub const S2N_STATUS_REQUEST_OCSP: Type = 1;
}
extern "C" {
    pub fn s2n_config_set_status_request_type(
        config: *mut s2n_config,
        type_: s2n_status_request_type::Type,
    ) -> ::libc::c_int;
}
pub mod s2n_ct_support_level {
    pub type Type = ::libc::c_uint;
    pub const S2N_CT_SUPPORT_NONE: Type = 0;
    pub const S2N_CT_SUPPORT_REQUEST: Type = 1;
}
extern "C" {
    pub fn s2n_config_set_ct_support_level(
        config: *mut s2n_config,
        level: s2n_ct_support_level::Type,
    ) -> ::libc::c_int;
}
pub mod s2n_alert_behavior {
    pub type Type = ::libc::c_uint;
    pub const S2N_ALERT_FAIL_ON_WARNINGS: Type = 0;
    pub const S2N_ALERT_IGNORE_WARNINGS: Type = 1;
}
extern "C" {
    pub fn s2n_config_set_alert_behavior(
        config: *mut s2n_config,
        alert_behavior: s2n_alert_behavior::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_extension_data(
        config: *mut s2n_config,
        type_: s2n_tls_extension_type::Type,
        data: *const u8,
        length: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_send_max_fragment_length(
        config: *mut s2n_config,
        mfl_code: s2n_max_frag_len::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_accept_max_fragment_length(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_session_state_lifetime(
        config: *mut s2n_config,
        lifetime_in_secs: u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_session_tickets_onoff(
        config: *mut s2n_config,
        enabled: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_session_cache_onoff(
        config: *mut s2n_config,
        enabled: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_ticket_encrypt_decrypt_key_lifetime(
        config: *mut s2n_config,
        lifetime_in_secs: u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_ticket_decrypt_key_lifetime(
        config: *mut s2n_config,
        lifetime_in_secs: u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_ticket_crypto_key(
        config: *mut s2n_config,
        name: *const u8,
        name_len: u32,
        key: *mut u8,
        key_len: u32,
        intro_time_in_seconds_from_epoch: u64,
    ) -> ::libc::c_int;
}
pub mod s2n_mode {
    pub type Type = ::libc::c_uint;
    pub const S2N_SERVER: Type = 0;
    pub const S2N_CLIENT: Type = 1;
}
extern "C" {
    pub fn s2n_connection_new(mode: s2n_mode::Type) -> *mut s2n_connection;
}
extern "C" {
    pub fn s2n_connection_set_config(
        conn: *mut s2n_connection,
        config: *mut s2n_config,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_ctx(
        conn: *mut s2n_connection,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_ctx(conn: *mut s2n_connection) -> *mut ::libc::c_void;
}
pub type s2n_client_hello_fn = ::core::option::Option<
    unsafe extern "C" fn(conn: *mut s2n_connection, ctx: *mut ::libc::c_void) -> ::libc::c_int,
>;
pub mod s2n_client_hello_cb_mode {
    pub type Type = ::libc::c_uint;
    pub const S2N_CLIENT_HELLO_CB_BLOCKING: Type = 0;
    pub const S2N_CLIENT_HELLO_CB_NONBLOCKING: Type = 1;
}
extern "C" {
    pub fn s2n_config_set_client_hello_cb(
        config: *mut s2n_config,
        client_hello_callback: s2n_client_hello_fn,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_client_hello_cb_mode(
        config: *mut s2n_config,
        cb_mode: s2n_client_hello_cb_mode::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_hello_cb_done(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_server_name_extension_used(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_client_hello(conn: *mut s2n_connection) -> *mut s2n_client_hello;
}
extern "C" {
    pub fn s2n_client_hello_get_raw_message_length(ch: *mut s2n_client_hello) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_raw_message(
        ch: *mut s2n_client_hello,
        out: *mut u8,
        max_length: u32,
    ) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_cipher_suites_length(ch: *mut s2n_client_hello) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_cipher_suites(
        ch: *mut s2n_client_hello,
        out: *mut u8,
        max_length: u32,
    ) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_extensions_length(ch: *mut s2n_client_hello) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_extensions(
        ch: *mut s2n_client_hello,
        out: *mut u8,
        max_length: u32,
    ) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_extension_length(
        ch: *mut s2n_client_hello,
        extension_type: s2n_tls_extension_type::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_extension_by_id(
        ch: *mut s2n_client_hello,
        extension_type: s2n_tls_extension_type::Type,
        out: *mut u8,
        max_length: u32,
    ) -> isize;
}
extern "C" {
    pub fn s2n_connection_set_fd(conn: *mut s2n_connection, fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_read_fd(
        conn: *mut s2n_connection,
        readfd: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_write_fd(
        conn: *mut s2n_connection,
        writefd: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_use_corked_io(conn: *mut s2n_connection) -> ::libc::c_int;
}
pub type s2n_recv_fn = ::core::option::Option<
    unsafe extern "C" fn(io_context: *mut ::libc::c_void, buf: *mut u8, len: u32) -> ::libc::c_int,
>;
pub type s2n_send_fn = ::core::option::Option<
    unsafe extern "C" fn(
        io_context: *mut ::libc::c_void,
        buf: *const u8,
        len: u32,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_connection_set_recv_ctx(
        conn: *mut s2n_connection,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_send_ctx(
        conn: *mut s2n_connection,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_recv_cb(
        conn: *mut s2n_connection,
        recv: s2n_recv_fn,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_send_cb(
        conn: *mut s2n_connection,
        send: s2n_send_fn,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_prefer_throughput(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_prefer_low_latency(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_dynamic_record_threshold(
        conn: *mut s2n_connection,
        resize_threshold: u32,
        timeout_threshold: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_verify_host_callback(
        config: *mut s2n_connection,
        host_fn: s2n_verify_host_fn,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
pub mod s2n_blinding {
    pub type Type = ::libc::c_uint;
    pub const S2N_BUILT_IN_BLINDING: Type = 0;
    pub const S2N_SELF_SERVICE_BLINDING: Type = 1;
}
extern "C" {
    pub fn s2n_connection_set_blinding(
        conn: *mut s2n_connection,
        blinding: s2n_blinding::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_delay(conn: *mut s2n_connection) -> u64;
}
extern "C" {
    pub fn s2n_connection_set_cipher_preferences(
        conn: *mut s2n_connection,
        version: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Appends the provided application protocol to the preference list"]
    #[doc = ""]
    #[doc = " The data provided in `protocol` parameter will be copied into an internal buffer"]
    #[doc = ""]
    #[doc = " @param conn The connection object being updated"]
    #[doc = " @param protocol A pointer to a slice of bytes"]
    #[doc = " @param protocol_len The length of bytes that should be read from `protocol`. Note: this value cannot be 0, otherwise an error will be returned."]
    pub fn s2n_connection_append_protocol_preference(
        conn: *mut s2n_connection,
        protocol: *const u8,
        protocol_len: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_protocol_preferences(
        conn: *mut s2n_connection,
        protocols: *const *const ::libc::c_char,
        protocol_count: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_set_server_name(
        conn: *mut s2n_connection,
        server_name: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_get_server_name(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_get_application_protocol(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_ocsp_response(
        conn: *mut s2n_connection,
        length: *mut u32,
    ) -> *const u8;
}
extern "C" {
    pub fn s2n_connection_get_sct_list(conn: *mut s2n_connection, length: *mut u32) -> *const u8;
}
pub mod s2n_blocked_status {
    pub type Type = ::libc::c_uint;
    pub const S2N_NOT_BLOCKED: Type = 0;
    pub const S2N_BLOCKED_ON_READ: Type = 1;
    pub const S2N_BLOCKED_ON_WRITE: Type = 2;
    pub const S2N_BLOCKED_ON_APPLICATION_INPUT: Type = 3;
    pub const S2N_BLOCKED_ON_EARLY_DATA: Type = 4;
}
extern "C" {
    pub fn s2n_negotiate(
        conn: *mut s2n_connection,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_send(
        conn: *mut s2n_connection,
        buf: *const ::libc::c_void,
        size: isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_sendv(
        conn: *mut s2n_connection,
        bufs: *const iovec,
        count: isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_sendv_with_offset(
        conn: *mut s2n_connection,
        bufs: *const iovec,
        count: isize,
        offs: isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_recv(
        conn: *mut s2n_connection,
        buf: *mut ::libc::c_void,
        size: isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_peek(conn: *mut s2n_connection) -> u32;
}
extern "C" {
    pub fn s2n_connection_free_handshake(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_release_buffers(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_wipe(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_free(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_shutdown(
        conn: *mut s2n_connection,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
pub mod s2n_cert_auth_type {
    pub type Type = ::libc::c_uint;
    pub const S2N_CERT_AUTH_NONE: Type = 0;
    pub const S2N_CERT_AUTH_REQUIRED: Type = 1;
    pub const S2N_CERT_AUTH_OPTIONAL: Type = 2;
}
extern "C" {
    pub fn s2n_config_get_client_auth_type(
        config: *mut s2n_config,
        client_auth_type: *mut s2n_cert_auth_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_client_auth_type(
        config: *mut s2n_config,
        client_auth_type: s2n_cert_auth_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_client_auth_type(
        conn: *mut s2n_connection,
        client_auth_type: *mut s2n_cert_auth_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_client_auth_type(
        conn: *mut s2n_connection,
        client_auth_type: s2n_cert_auth_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_client_cert_chain(
        conn: *mut s2n_connection,
        der_cert_chain_out: *mut *mut u8,
        cert_chain_len: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_session(
        conn: *mut s2n_connection,
        session: *const u8,
        length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session(
        conn: *mut s2n_connection,
        session: *mut u8,
        max_length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session_ticket_lifetime_hint(
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session_length(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session_id_length(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session_id(
        conn: *mut s2n_connection,
        session_id: *mut u8,
        max_length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_is_session_resumed(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_is_ocsp_stapled(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_selected_cert(
        conn: *mut s2n_connection,
    ) -> *mut s2n_cert_chain_and_key;
}
extern "C" {
    #[doc = " Returns the length of the s2n certificate chain `chain_and_key`."]
    #[doc = ""]
    #[doc = " @param chain_and_key A pointer to the s2n_cert_chain_and_key object being read."]
    #[doc = " @param cert_length This return value represents the length of the s2n certificate chain `chain_and_key`."]
    pub fn s2n_cert_chain_get_length(
        chain_and_key: *const s2n_cert_chain_and_key,
        cert_length: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the certificate `out_cert` present at the index `cert_idx` of the certificate chain `chain_and_key`."]
    #[doc = ""]
    #[doc = " Note that the index of the leaf certificate is zero. If the certificate chain `chain_and_key` is NULL or the"]
    #[doc = " certificate index value is not in the acceptable range for the input certificate chain, an error is returned."]
    #[doc = ""]
    #[doc = " @param chain_and_key A pointer to the s2n_cert_chain_and_key object being read."]
    #[doc = " @param cert_idx The certificate index for the requested certificate within the s2n certificate chain."]
    #[doc = " @param cert_length This return value represents the length of the s2n certificate chain `chain_and_key`."]
    pub fn s2n_cert_chain_get_cert(
        chain_and_key: *const s2n_cert_chain_and_key,
        out_cert: *mut *mut s2n_cert,
        cert_idx: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the s2n certificate in DER format along with its length."]
    #[doc = ""]
    #[doc = " The API gets the s2n certificate `cert` in DER format. The certificate is returned in the `out_cert_der` buffer."]
    #[doc = " Here, `cert_len` represents the length of the certificate."]
    #[doc = ""]
    #[doc = " A caller can use certificate parsing tools such as the ones provided by OpenSSL to parse the DER encoded certificate chain returned."]
    #[doc = ""]
    #[doc = " # Safety"]
    #[doc = ""]
    #[doc = " The memory for the `out_cert_der` buffer is allocated and owned by s2n-tls."]
    #[doc = " Since the size of the certificate can potentially be very large, a pointer to internal connection data is returned instead of"]
    #[doc = " copying the contents into a caller-provided buffer."]
    #[doc = ""]
    #[doc = " The pointer to the output buffer `out_cert_der` is valid only while the connection exists."]
    #[doc = " The `s2n_connection_free` API frees the memory assosciated with the out_cert_der buffer and after the `s2n_connection_wipe` API is"]
    #[doc = " called the memory pointed by out_cert_der is invalid."]
    #[doc = ""]
    #[doc = " If a caller wishes to persist the `out_cert_der` beyond the lifetime of the connection, the contents would need to be"]
    #[doc = " copied prior to the connection termination."]
    #[doc = ""]
    #[doc = " @param cert A pointer to the s2n_cert object being read."]
    #[doc = " @param out_cert_der A pointer to the output buffer which will hold the s2n certificate `cert` in DER format."]
    #[doc = " @param cert_length This return value represents the length of the certificate."]
    pub fn s2n_cert_get_der(
        cert: *const s2n_cert,
        out_cert_der: *mut *const u8,
        cert_length: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the validated peer certificate chain as a `s2n_cert_chain_and_key` opaque object."]
    #[doc = ""]
    #[doc = " The `s2n_cert_chain_and_key` parameter must be allocated by the caller using the `s2n_cert_chain_and_key_new` API"]
    #[doc = " prior to this function call and must be empty. To free the memory associated with the `s2n_cert_chain_and_key` object use the"]
    #[doc = " `s2n_cert_chain_and_key_free` API."]
    #[doc = ""]
    #[doc = " @param conn A pointer to the s2n_connection object being read."]
    #[doc = " @param s2n_cert_chain_and_key The returned validated peer certificate chain `cert_chain` retrieved from the s2n connection."]
    pub fn s2n_connection_get_peer_cert_chain(
        conn: *const s2n_connection,
        cert_chain: *mut s2n_cert_chain_and_key,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the length of the DER encoded extension value of the ASN.1 X.509 certificate extension."]
    #[doc = ""]
    #[doc = " @param cert A pointer to the s2n_cert object being read."]
    #[doc = " @param oid A null-terminated cstring that contains the OID of the X.509 certificate extension to be read."]
    #[doc = " @param ext_value_len This return value contains the length of DER encoded extension value of the ASN.1 X.509 certificate extension."]
    pub fn s2n_cert_get_x509_extension_value_length(
        cert: *mut s2n_cert,
        oid: *const u8,
        ext_value_len: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the DER encoding of an ASN.1 X.509 certificate extension value, it's length and a boolean critical."]
    #[doc = ""]
    #[doc = " @param cert A pointer to the s2n_cert object being read."]
    #[doc = " @param oid A null-terminated cstring that contains the OID of the X.509 certificate extension to be read."]
    #[doc = " @param ext_value A pointer to the output buffer which will hold the DER encoding of an ASN.1 X.509 certificate extension value returned."]
    #[doc = " @param ext_value_len  This value is both an input and output parameter and represents the length of the output buffer `ext_value`."]
    #[doc = " When used as an input parameter, the caller must use this parameter to convey the maximum length of `ext_value`."]
    #[doc = " When used as an output parameter, `ext_value_len` holds the actual length of the DER encoding of the ASN.1 X.509 certificate extension value returned."]
    #[doc = " @param critical This return value contains the boolean value for `critical`."]
    pub fn s2n_cert_get_x509_extension_value(
        cert: *mut s2n_cert,
        oid: *const u8,
        ext_value: *mut u8,
        ext_value_len: *mut u32,
        critical: *mut bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the UTF8 String length of the ASN.1 X.509 certificate extension data."]
    #[doc = ""]
    #[doc = " @param extension_data A pointer to the DER encoded ASN.1 X.509 certificate extension value being read."]
    #[doc = " @param extension_len represents the length of the input buffer `extension_data`."]
    #[doc = " @param utf8_str_len This return value contains the UTF8 String length of the ASN.1 X.509 certificate extension data."]
    pub fn s2n_cert_get_utf8_string_from_extension_data_length(
        extension_data: *const u8,
        extension_len: u32,
        utf8_str_len: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the UTF8 String representation of the DER encoded ASN.1 X.509 certificate extension data."]
    #[doc = ""]
    #[doc = " @param extension_data A pointer to the DER encoded ASN.1 X.509 certificate extension value being read."]
    #[doc = " @param extension_len represents the length of the input buffer `extension_data`."]
    #[doc = " @param out_data A pointer to the output buffer which will hold the UTF8 String representation of the DER encoded ASN.1 X.509"]
    #[doc = " certificate extension data returned."]
    #[doc = " @param out_len This value is both an input and output parameter and represents the length of the output buffer `out_data`."]
    #[doc = " When used as an input parameter, the caller must use this parameter to convey the maximum length of `out_data`."]
    #[doc = " When used as an output parameter, `out_len` holds the actual length of UTF8 String returned."]
    pub fn s2n_cert_get_utf8_string_from_extension_data(
        extension_data: *const u8,
        extension_len: u32,
        out_data: *mut u8,
        out_len: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_wire_bytes_in(conn: *mut s2n_connection) -> u64;
}
extern "C" {
    pub fn s2n_connection_get_wire_bytes_out(conn: *mut s2n_connection) -> u64;
}
extern "C" {
    pub fn s2n_connection_get_client_protocol_version(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_server_protocol_version(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_actual_protocol_version(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_client_hello_version(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_client_cert_used(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_cipher(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " Returns the IANA value for the connection's negotiated cipher suite."]
    #[doc = ""]
    #[doc = " The value is returned in the form of `first,second`, in order to closely match"]
    #[doc = " the values defined in the [IANA Registry](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#table-tls-parameters-4)."]
    #[doc = " For example if the connection's negotiated cipher suite is `TLS_AES_128_GCM_SHA256`,"]
    #[doc = " which is registered as `0x13,0x01`, then `first = 0x13` and `second = 0x01`."]
    #[doc = ""]
    #[doc = " This method will only succeed after the cipher suite has been negotiated with the peer."]
    #[doc = ""]
    #[doc = " @param conn A pointer to the connection being read"]
    #[doc = " @param first A pointer to a single byte, which will be updated with the first byte in the registered IANA value."]
    #[doc = " @param second A pointer to a single byte, which will be updated with the second byte in the registered IANA value."]
    #[doc = " @return A POSIX error signal. If an error was returned, the values contained in `first` and `second` should be considered invalid."]
    pub fn s2n_connection_get_cipher_iana_value(
        conn: *mut s2n_connection,
        first: *mut u8,
        second: *mut u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_is_valid_for_cipher_preferences(
        conn: *mut s2n_connection,
        version: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_curve(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_kem_name(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_kem_group_name(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_alert(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_handshake_type_name(
        conn: *mut s2n_connection,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_last_message_name(conn: *mut s2n_connection)
        -> *const ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_async_pkey_op {
    _unused: [u8; 0],
}
pub type s2n_async_pkey_fn = ::core::option::Option<
    unsafe extern "C" fn(conn: *mut s2n_connection, op: *mut s2n_async_pkey_op) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_config_set_async_pkey_callback(
        config: *mut s2n_config,
        fn_: s2n_async_pkey_fn,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_async_pkey_op_perform(
        op: *mut s2n_async_pkey_op,
        key: *mut s2n_cert_private_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_async_pkey_op_apply(
        op: *mut s2n_async_pkey_op,
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_async_pkey_op_free(op: *mut s2n_async_pkey_op) -> ::libc::c_int;
}
#[doc = " Callback function for handling key log events"]
#[doc = ""]
#[doc = " THIS SHOULD BE USED FOR DEBUGGING PURPOSES ONLY!"]
#[doc = ""]
#[doc = " Each log line is formatted with the"]
#[doc = " [NSS Key Log Format](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format)"]
#[doc = " without a newline."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " * `ctx` MUST be cast into the same type of pointer that was originally created"]
#[doc = " * `logline` bytes MUST be copied or discarded before this function returns"]
#[doc = ""]
#[doc = " @param ctx Context for the callback"]
#[doc = " @param conn Connection for which the log line is being emitted"]
#[doc = " @param logline Pointer to the log line data"]
#[doc = " @param len Length of the log line data"]
pub type s2n_key_log_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        conn: *mut s2n_connection,
        logline: *mut u8,
        len: usize,
    ) -> ::libc::c_int,
>;
extern "C" {
    #[doc = " Sets a key logging callback on the provided config"]
    #[doc = ""]
    #[doc = " THIS SHOULD BE USED FOR DEBUGGING PURPOSES ONLY!"]
    #[doc = ""]
    #[doc = " Setting this function enables configurations to emit secrets in the"]
    #[doc = " [NSS Key Log Format](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format)"]
    #[doc = ""]
    #[doc = " # Safety"]
    #[doc = ""]
    #[doc = " * `callback` MUST cast `ctx` into the same type of pointer that was originally created"]
    #[doc = " * `ctx` MUST live for at least as long as it is set on the config"]
    #[doc = ""]
    #[doc = " @param config Config to set the callback"]
    #[doc = " @param callback The function that should be called for each secret log entry"]
    #[doc = " @param ctx The context to be passed when the callback is called"]
    pub fn s2n_config_set_key_log_cb(
        config: *mut s2n_config,
        callback: s2n_key_log_fn,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_enable_cert_req_dss_legacy_compat(config: *mut s2n_config) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_cipher_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_CIPHER_CTX = evp_cipher_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_st {
    _unused: [u8; 0],
}
pub type EVP_MD = evp_md_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_md_ctx_st {
    _unused: [u8; 0],
}
pub type EVP_MD_CTX = evp_md_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evp_pkey_st {
    _unused: [u8; 0],
}
pub type EVP_PKEY = evp_pkey_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dh_st {
    _unused: [u8; 0],
}
pub type DH = dh_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rsa_st {
    _unused: [u8; 0],
}
pub type RSA = rsa_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ec_key_st {
    _unused: [u8; 0],
}
pub type EC_KEY = ec_key_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_st {
    _unused: [u8; 0],
}
pub type X509 = x509_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_st {
    _unused: [u8; 0],
}
pub type X509_STORE = x509_store_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct x509_store_ctx_st {
    _unused: [u8; 0],
}
pub type X509_STORE_CTX = x509_store_ctx_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHAstate_st {
    pub h0: ::libc::c_uint,
    pub h1: ::libc::c_uint,
    pub h2: ::libc::c_uint,
    pub h3: ::libc::c_uint,
    pub h4: ::libc::c_uint,
    pub Nl: ::libc::c_uint,
    pub Nh: ::libc::c_uint,
    pub data: [::libc::c_uint; 16usize],
    pub num: ::libc::c_uint,
}
pub type SHA_CTX = SHAstate_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHA256state_st {
    pub h: [::libc::c_uint; 8usize],
    pub Nl: ::libc::c_uint,
    pub Nh: ::libc::c_uint,
    pub data: [::libc::c_uint; 16usize],
    pub num: ::libc::c_uint,
    pub md_len: ::libc::c_uint,
}
pub type SHA256_CTX = SHA256state_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SHA512state_st {
    pub h: [::libc::c_ulonglong; 8usize],
    pub Nl: ::libc::c_ulonglong,
    pub Nh: ::libc::c_ulonglong,
    pub u: SHA512state_st__bindgen_ty_1,
    pub num: ::libc::c_uint,
    pub md_len: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SHA512state_st__bindgen_ty_1 {
    pub d: [::libc::c_ulonglong; 16usize],
    pub p: [::libc::c_uchar; 128usize],
}
pub type SHA512_CTX = SHA512state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_st_X509 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MD5state_st {
    pub A: ::libc::c_uint,
    pub B: ::libc::c_uint,
    pub C: ::libc::c_uint,
    pub D: ::libc::c_uint,
    pub Nl: ::libc::c_uint,
    pub Nh: ::libc::c_uint,
    pub data: [::libc::c_uint; 16usize],
    pub num: ::libc::c_uint,
}
pub type MD5_CTX = MD5state_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_result {
    pub __error_signal: ::libc::c_int,
}
extern "C" {
    #[must_use]
    pub fn s2n_result_is_ok(result: s2n_result) -> bool;
}
extern "C" {
    #[must_use]
    pub fn s2n_result_is_error(result: s2n_result) -> bool;
}
extern "C" {
    #[doc = " Ignores the returned result of a function"]
    #[doc = ""]
    #[doc = " Generally, function results should always be checked. Using this function"]
    #[doc = " could cause the system to behave in unexpected ways. As such, this function"]
    #[doc = " should only be used in scenarios where the system state is not affected by"]
    #[doc = " errors."]
    pub fn s2n_result_ignore(result: s2n_result);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_evp_digest {
    pub md: *const EVP_MD,
    pub ctx: *mut EVP_MD_CTX,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_evp_hmac_state {
    pub evp_digest: s2n_evp_digest,
    pub mac_key: *mut EVP_PKEY,
}
extern "C" {
    pub fn s2n_digest_allow_md5_for_fips(evp_digest: *mut s2n_evp_digest) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_digest_is_md5_allowed_for_fips(
        evp_digest: *mut s2n_evp_digest,
        out: *mut bool,
    ) -> s2n_result;
}
pub mod s2n_hash_algorithm {
    pub type Type = ::libc::c_uint;
    pub const S2N_HASH_NONE: Type = 0;
    pub const S2N_HASH_MD5: Type = 1;
    pub const S2N_HASH_SHA1: Type = 2;
    pub const S2N_HASH_SHA224: Type = 3;
    pub const S2N_HASH_SHA256: Type = 4;
    pub const S2N_HASH_SHA384: Type = 5;
    pub const S2N_HASH_SHA512: Type = 6;
    pub const S2N_HASH_MD5_SHA1: Type = 7;
    pub const S2N_HASH_SENTINEL: Type = 8;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union s2n_hash_low_level_digest {
    pub md5: MD5_CTX,
    pub sha1: SHA_CTX,
    pub sha224: SHA256_CTX,
    pub sha256: SHA256_CTX,
    pub sha384: SHA512_CTX,
    pub sha512: SHA512_CTX,
    pub md5_sha1: s2n_hash_low_level_digest__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_hash_low_level_digest__bindgen_ty_1 {
    pub md5: MD5_CTX,
    pub sha1: SHA_CTX,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_hash_evp_digest {
    pub evp: s2n_evp_digest,
    pub evp_md5_secondary: s2n_evp_digest,
}
#[repr(C)]
pub struct s2n_hash_state {
    pub hash_impl: *const s2n_hash,
    pub alg: s2n_hash_algorithm::Type,
    pub is_ready_for_input: u8,
    pub currently_in_hash: u64,
    pub digest: s2n_hash_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union s2n_hash_state__bindgen_ty_1 {
    pub low_level: s2n_hash_low_level_digest,
    pub high_level: s2n_hash_evp_digest,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_hash {
    pub alloc:
        ::core::option::Option<unsafe extern "C" fn(state: *mut s2n_hash_state) -> ::libc::c_int>,
    pub allow_md5_for_fips:
        ::core::option::Option<unsafe extern "C" fn(state: *mut s2n_hash_state) -> ::libc::c_int>,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            state: *mut s2n_hash_state,
            alg: s2n_hash_algorithm::Type,
        ) -> ::libc::c_int,
    >,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            state: *mut s2n_hash_state,
            data: *const ::libc::c_void,
            size: u32,
        ) -> ::libc::c_int,
    >,
    pub digest: ::core::option::Option<
        unsafe extern "C" fn(
            state: *mut s2n_hash_state,
            out: *mut ::libc::c_void,
            size: u32,
        ) -> ::libc::c_int,
    >,
    pub copy: ::core::option::Option<
        unsafe extern "C" fn(to: *mut s2n_hash_state, from: *mut s2n_hash_state) -> ::libc::c_int,
    >,
    pub reset:
        ::core::option::Option<unsafe extern "C" fn(state: *mut s2n_hash_state) -> ::libc::c_int>,
    pub free:
        ::core::option::Option<unsafe extern "C" fn(state: *mut s2n_hash_state) -> ::libc::c_int>,
}
extern "C" {
    pub fn s2n_hash_digest_size(alg: s2n_hash_algorithm::Type, out: *mut u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_block_size(
        alg: s2n_hash_algorithm::Type,
        block_size: *mut u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_is_available(alg: s2n_hash_algorithm::Type) -> bool;
}
extern "C" {
    pub fn s2n_hash_is_ready_for_input(state: *mut s2n_hash_state) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_new(state: *mut s2n_hash_state) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_hash_state_validate(state: *mut s2n_hash_state) -> s2n_result;
}
extern "C" {
    pub fn s2n_hash_allow_md5_for_fips(state: *mut s2n_hash_state) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_init(
        state: *mut s2n_hash_state,
        alg: s2n_hash_algorithm::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_update(
        state: *mut s2n_hash_state,
        data: *const ::libc::c_void,
        size: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_digest(
        state: *mut s2n_hash_state,
        out: *mut ::libc::c_void,
        size: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_copy(to: *mut s2n_hash_state, from: *mut s2n_hash_state) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_reset(state: *mut s2n_hash_state) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_free(state: *mut s2n_hash_state) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_get_currently_in_hash_total(
        state: *mut s2n_hash_state,
        out: *mut u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_const_time_get_currently_in_hash_block(
        state: *mut s2n_hash_state,
        out: *mut u64,
    ) -> ::libc::c_int;
}
pub mod s2n_signature_algorithm {
    pub type Type = ::libc::c_uint;
    pub const S2N_SIGNATURE_ANONYMOUS: Type = 0;
    pub const S2N_SIGNATURE_RSA: Type = 1;
    pub const S2N_SIGNATURE_ECDSA: Type = 3;
    pub const S2N_SIGNATURE_RSA_PSS_RSAE: Type = 224;
    pub const S2N_SIGNATURE_RSA_PSS_PSS: Type = 225;
}
#[repr(C)]
pub struct s2n_blob {
    pub data: *mut u8,
    pub size: u32,
    pub allocated: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl s2n_blob {
    #[inline]
    pub fn growable(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_growable(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(growable: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let growable: u32 = unsafe { ::core::mem::transmute(growable) };
            growable as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn s2n_blob_is_growable(b: *const s2n_blob) -> bool;
}
extern "C" {
    #[must_use]
    pub fn s2n_blob_validate(b: *const s2n_blob) -> s2n_result;
}
extern "C" {
    pub fn s2n_blob_init(b: *mut s2n_blob, data: *mut u8, size: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_blob_zero(b: *mut s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_blob_char_to_lower(b: *mut s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hex_string_to_bytes(str_: *const u8, blob: *mut s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_blob_slice(
        b: *const s2n_blob,
        slice: *mut s2n_blob,
        offset: u32,
        size: u32,
    ) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_stuffer {
    pub blob: s2n_blob,
    pub read_cursor: u32,
    pub write_cursor: u32,
    pub high_water_mark: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl s2n_stuffer {
    #[inline]
    pub fn alloced(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alloced(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn growable(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_growable(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tainted(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tainted(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        alloced: ::libc::c_uint,
        growable: ::libc::c_uint,
        tainted: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let alloced: u32 = unsafe { ::core::mem::transmute(alloced) };
            alloced as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let growable: u32 = unsafe { ::core::mem::transmute(growable) };
            growable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tainted: u32 = unsafe { ::core::mem::transmute(tainted) };
            tainted as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[must_use]
    pub fn s2n_stuffer_validate(stuffer: *const s2n_stuffer) -> s2n_result;
}
extern "C" {
    pub fn s2n_stuffer_init(stuffer: *mut s2n_stuffer, in_: *mut s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_alloc(stuffer: *mut s2n_stuffer, size: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_growable_alloc(stuffer: *mut s2n_stuffer, size: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_free(stuffer: *mut s2n_stuffer) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_resize(stuffer: *mut s2n_stuffer, size: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_resize_if_empty(stuffer: *mut s2n_stuffer, size: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_rewind_read(stuffer: *mut s2n_stuffer, size: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_reread(stuffer: *mut s2n_stuffer) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_rewrite(stuffer: *mut s2n_stuffer) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_wipe(stuffer: *mut s2n_stuffer) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_wipe_n(stuffer: *mut s2n_stuffer, n: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_is_consumed(stuffer: *mut s2n_stuffer) -> bool;
}
extern "C" {
    pub fn s2n_stuffer_read(stuffer: *mut s2n_stuffer, out: *mut s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_erase_and_read(
        stuffer: *mut s2n_stuffer,
        out: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write(stuffer: *mut s2n_stuffer, in_: *const s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_bytes(stuffer: *mut s2n_stuffer, out: *mut u8, n: u32)
        -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_erase_and_read_bytes(
        stuffer: *mut s2n_stuffer,
        data: *mut u8,
        size: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_bytes(
        stuffer: *mut s2n_stuffer,
        in_: *const u8,
        n: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_writev_bytes(
        stuffer: *mut s2n_stuffer,
        iov: *const iovec,
        iov_count: usize,
        offs: u32,
        size: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_skip_read(stuffer: *mut s2n_stuffer, n: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_skip_write(stuffer: *mut s2n_stuffer, n: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_reserve_space(stuffer: *mut s2n_stuffer, n: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_raw_write(stuffer: *mut s2n_stuffer, data_len: u32) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn s2n_stuffer_raw_read(stuffer: *mut s2n_stuffer, data_len: u32) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn s2n_stuffer_recv_from_fd(
        stuffer: *mut s2n_stuffer,
        rfd: ::libc::c_int,
        len: u32,
        bytes_written: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_send_to_fd(
        stuffer: *mut s2n_stuffer,
        wfd: ::libc::c_int,
        len: u32,
        bytes_sent: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_uint8(stuffer: *mut s2n_stuffer, u: *mut u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_uint16(stuffer: *mut s2n_stuffer, u: *mut u16) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_uint24(stuffer: *mut s2n_stuffer, u: *mut u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_uint32(stuffer: *mut s2n_stuffer, u: *mut u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_uint64(stuffer: *mut s2n_stuffer, u: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_uint8(stuffer: *mut s2n_stuffer, u: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_uint16(stuffer: *mut s2n_stuffer, u: u16) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_uint24(stuffer: *mut s2n_stuffer, u: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_uint32(stuffer: *mut s2n_stuffer, u: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_uint64(stuffer: *mut s2n_stuffer, u: u64) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_stuffer_reservation {
    pub stuffer: *mut s2n_stuffer,
    pub write_cursor: u32,
    pub length: u8,
}
extern "C" {
    #[must_use]
    pub fn s2n_stuffer_reservation_validate(
        reservation: *const s2n_stuffer_reservation,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_stuffer_reserve_uint16(
        stuffer: *mut s2n_stuffer,
        reservation: *mut s2n_stuffer_reservation,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_reserve_uint24(
        stuffer: *mut s2n_stuffer,
        reservation: *mut s2n_stuffer_reservation,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_vector_size(
        reservation: *mut s2n_stuffer_reservation,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_copy(
        from: *mut s2n_stuffer,
        to: *mut s2n_stuffer,
        len: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_base64(
        stuffer: *mut s2n_stuffer,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_base64(
        stuffer: *mut s2n_stuffer,
        in_: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_expected_str(
        stuffer: *mut s2n_stuffer,
        expected: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_peek_char(
        stuffer: *mut s2n_stuffer,
        c: *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_token(
        stuffer: *mut s2n_stuffer,
        token: *mut s2n_stuffer,
        delim: ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_line(
        stuffer: *mut s2n_stuffer,
        token: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_peek_check_for_str(
        s2n_stuffer: *mut s2n_stuffer,
        expected: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_skip_whitespace(
        stuffer: *mut s2n_stuffer,
        skipped: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_skip_to_char(
        stuffer: *mut s2n_stuffer,
        target: ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_skip_expected_char(
        stuffer: *mut s2n_stuffer,
        expected: ::libc::c_char,
        min: u32,
        max: u32,
        skipped: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_skip_read_until(
        stuffer: *mut s2n_stuffer,
        target: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_alloc_ro_from_string(
        stuffer: *mut s2n_stuffer,
        str_: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_private_key_from_pem(
        pem: *mut s2n_stuffer,
        asn1: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_certificate_from_pem(
        pem: *mut s2n_stuffer,
        asn1: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_dhparams_from_pem(
        pem: *mut s2n_stuffer,
        pkcs3: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_is_base64_char(c: ::libc::c_uchar) -> bool;
}
extern "C" {
    pub fn s2n_stuffer_extract_blob(stuffer: *mut s2n_stuffer, out: *mut s2n_blob)
        -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_ecdhe_raw_server_params {
    pub point_blob: s2n_blob,
    pub curve_blob: s2n_blob,
}
#[repr(C)]
pub struct s2n_dhe_raw_server_points {
    pub p: s2n_blob,
    pub g: s2n_blob,
    pub Ys: s2n_blob,
}
#[repr(C)]
pub struct s2n_kem_raw_server_params {
    pub kem_name: s2n_blob,
    pub raw_public_key: s2n_blob,
}
#[repr(C)]
pub struct s2n_kex_raw_server_data {
    pub ecdhe_data: s2n_ecdhe_raw_server_params,
    pub dhe_data: s2n_dhe_raw_server_points,
    pub kem_data: s2n_kem_raw_server_params,
}
pub mod s2n_error {
    pub type Type = ::libc::c_uint;
    pub const S2N_ERR_OK: Type = 0;
    pub const S2N_ERR_T_OK_END: Type = 1;
    pub const S2N_ERR_IO: Type = 67108864;
    pub const S2N_ERR_T_IO_END: Type = 67108865;
    pub const S2N_ERR_CLOSED: Type = 134217728;
    pub const S2N_ERR_T_CLOSED_END: Type = 134217729;
    pub const S2N_ERR_IO_BLOCKED: Type = 201326592;
    pub const S2N_ERR_ASYNC_BLOCKED: Type = 201326593;
    pub const S2N_ERR_EARLY_DATA_BLOCKED: Type = 201326594;
    pub const S2N_ERR_T_BLOCKED_END: Type = 201326595;
    pub const S2N_ERR_ALERT: Type = 268435456;
    pub const S2N_ERR_T_ALERT_END: Type = 268435457;
    pub const S2N_ERR_ENCRYPT: Type = 335544320;
    pub const S2N_ERR_DECRYPT: Type = 335544321;
    pub const S2N_ERR_BAD_MESSAGE: Type = 335544322;
    pub const S2N_ERR_KEY_INIT: Type = 335544323;
    pub const S2N_ERR_KEY_DESTROY: Type = 335544324;
    pub const S2N_ERR_DH_SERIALIZING: Type = 335544325;
    pub const S2N_ERR_DH_SHARED_SECRET: Type = 335544326;
    pub const S2N_ERR_DH_WRITING_PUBLIC_KEY: Type = 335544327;
    pub const S2N_ERR_DH_FAILED_SIGNING: Type = 335544328;
    pub const S2N_ERR_DH_COPYING_PARAMETERS: Type = 335544329;
    pub const S2N_ERR_DH_GENERATING_PARAMETERS: Type = 335544330;
    pub const S2N_ERR_CIPHER_NOT_SUPPORTED: Type = 335544331;
    pub const S2N_ERR_NO_APPLICATION_PROTOCOL: Type = 335544332;
    pub const S2N_ERR_FALLBACK_DETECTED: Type = 335544333;
    pub const S2N_ERR_HASH_DIGEST_FAILED: Type = 335544334;
    pub const S2N_ERR_HASH_INIT_FAILED: Type = 335544335;
    pub const S2N_ERR_HASH_UPDATE_FAILED: Type = 335544336;
    pub const S2N_ERR_HASH_COPY_FAILED: Type = 335544337;
    pub const S2N_ERR_HASH_WIPE_FAILED: Type = 335544338;
    pub const S2N_ERR_HASH_NOT_READY: Type = 335544339;
    pub const S2N_ERR_ALLOW_MD5_FOR_FIPS_FAILED: Type = 335544340;
    pub const S2N_ERR_DECODE_CERTIFICATE: Type = 335544341;
    pub const S2N_ERR_DECODE_PRIVATE_KEY: Type = 335544342;
    pub const S2N_ERR_INVALID_HELLO_RETRY: Type = 335544343;
    pub const S2N_ERR_INVALID_SIGNATURE_ALGORITHM: Type = 335544344;
    pub const S2N_ERR_INVALID_SIGNATURE_SCHEME: Type = 335544345;
    pub const S2N_ERR_CBC_VERIFY: Type = 335544346;
    pub const S2N_ERR_DH_COPYING_PUBLIC_KEY: Type = 335544347;
    pub const S2N_ERR_SIGN: Type = 335544348;
    pub const S2N_ERR_VERIFY_SIGNATURE: Type = 335544349;
    pub const S2N_ERR_ECDHE_GEN_KEY: Type = 335544350;
    pub const S2N_ERR_ECDHE_SHARED_SECRET: Type = 335544351;
    pub const S2N_ERR_ECDHE_UNSUPPORTED_CURVE: Type = 335544352;
    pub const S2N_ERR_ECDSA_UNSUPPORTED_CURVE: Type = 335544353;
    pub const S2N_ERR_ECDHE_SERIALIZING: Type = 335544354;
    pub const S2N_ERR_KEM_UNSUPPORTED_PARAMS: Type = 335544355;
    pub const S2N_ERR_SHUTDOWN_RECORD_TYPE: Type = 335544356;
    pub const S2N_ERR_SHUTDOWN_CLOSED: Type = 335544357;
    pub const S2N_ERR_NON_EMPTY_RENEGOTIATION_INFO: Type = 335544358;
    pub const S2N_ERR_RECORD_LIMIT: Type = 335544359;
    pub const S2N_ERR_CERT_UNTRUSTED: Type = 335544360;
    pub const S2N_ERR_CERT_TYPE_UNSUPPORTED: Type = 335544361;
    pub const S2N_ERR_INVALID_MAX_FRAG_LEN: Type = 335544362;
    pub const S2N_ERR_MAX_FRAG_LEN_MISMATCH: Type = 335544363;
    pub const S2N_ERR_PROTOCOL_VERSION_UNSUPPORTED: Type = 335544364;
    pub const S2N_ERR_BAD_KEY_SHARE: Type = 335544365;
    pub const S2N_ERR_CANCELLED: Type = 335544366;
    pub const S2N_ERR_PROTOCOL_DOWNGRADE_DETECTED: Type = 335544367;
    pub const S2N_ERR_MAX_INNER_PLAINTEXT_SIZE: Type = 335544368;
    pub const S2N_ERR_RECORD_STUFFER_SIZE: Type = 335544369;
    pub const S2N_ERR_FRAGMENT_LENGTH_TOO_LARGE: Type = 335544370;
    pub const S2N_ERR_FRAGMENT_LENGTH_TOO_SMALL: Type = 335544371;
    pub const S2N_ERR_RECORD_STUFFER_NEEDS_DRAINING: Type = 335544372;
    pub const S2N_ERR_MISSING_EXTENSION: Type = 335544373;
    pub const S2N_ERR_UNSUPPORTED_EXTENSION: Type = 335544374;
    pub const S2N_ERR_DUPLICATE_EXTENSION: Type = 335544375;
    pub const S2N_ERR_MAX_EARLY_DATA_SIZE: Type = 335544376;
    pub const S2N_ERR_T_PROTO_END: Type = 335544377;
    pub const S2N_ERR_MADVISE: Type = 402653184;
    pub const S2N_ERR_ALLOC: Type = 402653185;
    pub const S2N_ERR_MLOCK: Type = 402653186;
    pub const S2N_ERR_MUNLOCK: Type = 402653187;
    pub const S2N_ERR_FSTAT: Type = 402653188;
    pub const S2N_ERR_OPEN: Type = 402653189;
    pub const S2N_ERR_MMAP: Type = 402653190;
    pub const S2N_ERR_ATEXIT: Type = 402653191;
    pub const S2N_ERR_NOMEM: Type = 402653192;
    pub const S2N_ERR_NULL: Type = 402653193;
    pub const S2N_ERR_SAFETY: Type = 402653194;
    pub const S2N_ERR_INITIALIZED: Type = 402653195;
    pub const S2N_ERR_NOT_INITIALIZED: Type = 402653196;
    pub const S2N_ERR_RANDOM_UNINITIALIZED: Type = 402653197;
    pub const S2N_ERR_OPEN_RANDOM: Type = 402653198;
    pub const S2N_ERR_RESIZE_STATIC_STUFFER: Type = 402653199;
    pub const S2N_ERR_RESIZE_TAINTED_STUFFER: Type = 402653200;
    pub const S2N_ERR_STUFFER_OUT_OF_DATA: Type = 402653201;
    pub const S2N_ERR_STUFFER_IS_FULL: Type = 402653202;
    pub const S2N_ERR_STUFFER_NOT_FOUND: Type = 402653203;
    pub const S2N_ERR_STUFFER_HAS_UNPROCESSED_DATA: Type = 402653204;
    pub const S2N_ERR_HASH_INVALID_ALGORITHM: Type = 402653205;
    pub const S2N_ERR_PRF_INVALID_ALGORITHM: Type = 402653206;
    pub const S2N_ERR_PRF_INVALID_SEED: Type = 402653207;
    pub const S2N_ERR_P_HASH_INVALID_ALGORITHM: Type = 402653208;
    pub const S2N_ERR_P_HASH_INIT_FAILED: Type = 402653209;
    pub const S2N_ERR_P_HASH_UPDATE_FAILED: Type = 402653210;
    pub const S2N_ERR_P_HASH_FINAL_FAILED: Type = 402653211;
    pub const S2N_ERR_P_HASH_WIPE_FAILED: Type = 402653212;
    pub const S2N_ERR_HMAC_INVALID_ALGORITHM: Type = 402653213;
    pub const S2N_ERR_HKDF_OUTPUT_SIZE: Type = 402653214;
    pub const S2N_ERR_ALERT_PRESENT: Type = 402653215;
    pub const S2N_ERR_HANDSHAKE_STATE: Type = 402653216;
    pub const S2N_ERR_SHUTDOWN_PAUSED: Type = 402653217;
    pub const S2N_ERR_SIZE_MISMATCH: Type = 402653218;
    pub const S2N_ERR_DRBG: Type = 402653219;
    pub const S2N_ERR_DRBG_REQUEST_SIZE: Type = 402653220;
    pub const S2N_ERR_KEY_CHECK: Type = 402653221;
    pub const S2N_ERR_CIPHER_TYPE: Type = 402653222;
    pub const S2N_ERR_MAP_DUPLICATE: Type = 402653223;
    pub const S2N_ERR_MAP_IMMUTABLE: Type = 402653224;
    pub const S2N_ERR_MAP_MUTABLE: Type = 402653225;
    pub const S2N_ERR_MAP_INVALID_MAP_SIZE: Type = 402653226;
    pub const S2N_ERR_INITIAL_HMAC: Type = 402653227;
    pub const S2N_ERR_INVALID_NONCE_TYPE: Type = 402653228;
    pub const S2N_ERR_UNIMPLEMENTED: Type = 402653229;
    pub const S2N_ERR_HANDSHAKE_UNREACHABLE: Type = 402653230;
    pub const S2N_ERR_READ: Type = 402653231;
    pub const S2N_ERR_WRITE: Type = 402653232;
    pub const S2N_ERR_BAD_FD: Type = 402653233;
    pub const S2N_ERR_RDRAND_FAILED: Type = 402653234;
    pub const S2N_ERR_FAILED_CACHE_RETRIEVAL: Type = 402653235;
    pub const S2N_ERR_X509_TRUST_STORE: Type = 402653236;
    pub const S2N_ERR_UNKNOWN_PROTOCOL_VERSION: Type = 402653237;
    pub const S2N_ERR_NULL_CN_NAME: Type = 402653238;
    pub const S2N_ERR_NULL_SANS: Type = 402653239;
    pub const S2N_ERR_CLIENT_HELLO_VERSION: Type = 402653240;
    pub const S2N_ERR_CLIENT_PROTOCOL_VERSION: Type = 402653241;
    pub const S2N_ERR_SERVER_PROTOCOL_VERSION: Type = 402653242;
    pub const S2N_ERR_ACTUAL_PROTOCOL_VERSION: Type = 402653243;
    pub const S2N_ERR_POLLING_FROM_SOCKET: Type = 402653244;
    pub const S2N_ERR_RECV_STUFFER_FROM_CONN: Type = 402653245;
    pub const S2N_ERR_SEND_STUFFER_TO_CONN: Type = 402653246;
    pub const S2N_ERR_PRECONDITION_VIOLATION: Type = 402653247;
    pub const S2N_ERR_POSTCONDITION_VIOLATION: Type = 402653248;
    pub const S2N_ERR_INTEGER_OVERFLOW: Type = 402653249;
    pub const S2N_ERR_ARRAY_INDEX_OOB: Type = 402653250;
    pub const S2N_ERR_FREE_STATIC_BLOB: Type = 402653251;
    pub const S2N_ERR_RESIZE_STATIC_BLOB: Type = 402653252;
    pub const S2N_ERR_NO_SUPPORTED_LIBCRYPTO_API: Type = 402653253;
    pub const S2N_ERR_RECORD_LENGTH_TOO_LARGE: Type = 402653254;
    pub const S2N_ERR_SET_DUPLICATE_VALUE: Type = 402653255;
    pub const S2N_ERR_INVALID_PARSED_EXTENSIONS: Type = 402653256;
    pub const S2N_ERR_ASYNC_CALLBACK_FAILED: Type = 402653257;
    pub const S2N_ERR_ASYNC_MORE_THAN_ONE: Type = 402653258;
    pub const S2N_ERR_PQ_CRYPTO: Type = 402653259;
    pub const S2N_ERR_PQ_DISABLED: Type = 402653260;
    pub const S2N_ERR_INVALID_CERT_STATE: Type = 402653261;
    pub const S2N_ERR_INVALID_EARLY_DATA_STATE: Type = 402653262;
    pub const S2N_ERR_T_INTERNAL_END: Type = 402653263;
    pub const S2N_ERR_NO_ALERT: Type = 469762048;
    pub const S2N_ERR_SERVER_MODE: Type = 469762049;
    pub const S2N_ERR_CLIENT_MODE: Type = 469762050;
    pub const S2N_ERR_CLIENT_MODE_DISABLED: Type = 469762051;
    pub const S2N_ERR_TOO_MANY_CERTIFICATES: Type = 469762052;
    pub const S2N_ERR_TOO_MANY_SIGNATURE_SCHEMES: Type = 469762053;
    pub const S2N_ERR_CLIENT_AUTH_NOT_SUPPORTED_IN_FIPS_MODE: Type = 469762054;
    pub const S2N_ERR_INVALID_BASE64: Type = 469762055;
    pub const S2N_ERR_INVALID_HEX: Type = 469762056;
    pub const S2N_ERR_INVALID_PEM: Type = 469762057;
    pub const S2N_ERR_DH_PARAMS_CREATE: Type = 469762058;
    pub const S2N_ERR_DH_TOO_SMALL: Type = 469762059;
    pub const S2N_ERR_DH_PARAMETER_CHECK: Type = 469762060;
    pub const S2N_ERR_INVALID_PKCS3: Type = 469762061;
    pub const S2N_ERR_NO_CERTIFICATE_IN_PEM: Type = 469762062;
    pub const S2N_ERR_SERVER_NAME_TOO_LONG: Type = 469762063;
    pub const S2N_ERR_NUM_DEFAULT_CERTIFICATES: Type = 469762064;
    pub const S2N_ERR_MULTIPLE_DEFAULT_CERTIFICATES_PER_AUTH_TYPE: Type = 469762065;
    pub const S2N_ERR_INVALID_CIPHER_PREFERENCES: Type = 469762066;
    pub const S2N_ERR_INVALID_APPLICATION_PROTOCOL: Type = 469762067;
    pub const S2N_ERR_KEY_MISMATCH: Type = 469762068;
    pub const S2N_ERR_SEND_SIZE: Type = 469762069;
    pub const S2N_ERR_CORK_SET_ON_UNMANAGED: Type = 469762070;
    pub const S2N_ERR_UNRECOGNIZED_EXTENSION: Type = 469762071;
    pub const S2N_ERR_INVALID_SCT_LIST: Type = 469762072;
    pub const S2N_ERR_INVALID_OCSP_RESPONSE: Type = 469762073;
    pub const S2N_ERR_UPDATING_EXTENSION: Type = 469762074;
    pub const S2N_ERR_INVALID_SERIALIZED_SESSION_STATE: Type = 469762075;
    pub const S2N_ERR_SERIALIZED_SESSION_STATE_TOO_LONG: Type = 469762076;
    pub const S2N_ERR_SESSION_ID_TOO_LONG: Type = 469762077;
    pub const S2N_ERR_CLIENT_AUTH_NOT_SUPPORTED_IN_SESSION_RESUMPTION_MODE: Type = 469762078;
    pub const S2N_ERR_INVALID_TICKET_KEY_LENGTH: Type = 469762079;
    pub const S2N_ERR_INVALID_TICKET_KEY_NAME_OR_NAME_LENGTH: Type = 469762080;
    pub const S2N_ERR_TICKET_KEY_NOT_UNIQUE: Type = 469762081;
    pub const S2N_ERR_TICKET_KEY_LIMIT: Type = 469762082;
    pub const S2N_ERR_NO_TICKET_ENCRYPT_DECRYPT_KEY: Type = 469762083;
    pub const S2N_ERR_ENCRYPT_DECRYPT_KEY_SELECTION_FAILED: Type = 469762084;
    pub const S2N_ERR_KEY_USED_IN_SESSION_TICKET_NOT_FOUND: Type = 469762085;
    pub const S2N_ERR_SENDING_NST: Type = 469762086;
    pub const S2N_ERR_INVALID_DYNAMIC_THRESHOLD: Type = 469762087;
    pub const S2N_ERR_INVALID_ARGUMENT: Type = 469762088;
    pub const S2N_ERR_NOT_IN_UNIT_TEST: Type = 469762089;
    pub const S2N_ERR_NOT_IN_TEST: Type = 469762090;
    pub const S2N_ERR_UNSUPPORTED_CPU: Type = 469762091;
    pub const S2N_ERR_SESSION_ID_TOO_SHORT: Type = 469762092;
    pub const S2N_ERR_CONNECTION_CACHING_DISALLOWED: Type = 469762093;
    pub const S2N_ERR_SESSION_TICKET_NOT_SUPPORTED: Type = 469762094;
    pub const S2N_ERR_OCSP_NOT_SUPPORTED: Type = 469762095;
    pub const S2N_ERR_INVALID_SIGNATURE_ALGORITHMS_PREFERENCES: Type = 469762096;
    pub const S2N_RSA_PSS_NOT_SUPPORTED: Type = 469762097;
    pub const S2N_ERR_INVALID_ECC_PREFERENCES: Type = 469762098;
    pub const S2N_ERR_INVALID_SECURITY_POLICY: Type = 469762099;
    pub const S2N_ERR_INVALID_KEM_PREFERENCES: Type = 469762100;
    pub const S2N_ERR_ASYNC_ALREADY_PERFORMED: Type = 469762101;
    pub const S2N_ERR_ASYNC_NOT_PERFORMED: Type = 469762102;
    pub const S2N_ERR_ASYNC_WRONG_CONNECTION: Type = 469762103;
    pub const S2N_ERR_ASYNC_APPLY_WHILE_INVOKING: Type = 469762104;
    pub const S2N_ERR_ASYNC_ALREADY_APPLIED: Type = 469762105;
    pub const S2N_ERR_UNSUPPORTED_WITH_QUIC: Type = 469762106;
    pub const S2N_ERR_DUPLICATE_PSK_IDENTITIES: Type = 469762107;
    pub const S2N_ERR_OFFERED_PSKS_TOO_LONG: Type = 469762108;
    pub const S2N_ERR_INVALID_SESSION_TICKET: Type = 469762109;
    pub const S2N_ERR_REENTRANCY: Type = 469762110;
    pub const S2N_ERR_INVALID_STATE: Type = 469762111;
    pub const S2N_ERR_EARLY_DATA_NOT_ALLOWED: Type = 469762112;
    pub const S2N_ERR_NO_CERT_FOUND: Type = 469762113;
    pub const S2N_ERR_CERT_NOT_VALIDATED: Type = 469762114;
    pub const S2N_ERR_PSK_MODE: Type = 469762115;
    pub const S2N_ERR_X509_EXTENSION_VALUE_NOT_FOUND: Type = 469762116;
    pub const S2N_ERR_INVALID_X509_EXTENSION_TYPE: Type = 469762117;
    pub const S2N_ERR_INSUFFICIENT_MEM_SIZE: Type = 469762118;
    pub const S2N_ERR_KEYING_MATERIAL_EXPIRED: Type = 469762119;
    pub const S2N_ERR_T_USAGE_END: Type = 469762120;
}
extern "C" {
    pub static mut s2n_debug_str: *const ::libc::c_char;
}
#[doc = " Calculate and print stacktraces"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_stacktrace {
    pub trace: *mut *mut ::libc::c_char,
    pub trace_size: ::libc::c_int,
}
extern "C" {
    pub fn s2n_ensure_memcpy_trace(
        to: *mut ::libc::c_void,
        from: *const ::libc::c_void,
        size: usize,
        debug_str: *const ::libc::c_char,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn s2n_in_unit_test() -> bool;
}
extern "C" {
    pub fn s2n_in_unit_test_set(newval: bool) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the process id"]
    #[doc = ""]
    #[doc = " Returns:"]
    #[doc = "  The process ID of the current process"]
    pub fn s2n_actual_getpid() -> pid_t;
}
extern "C" {
    pub fn s2n_constant_time_equals(a: *const u8, b: *const u8, len: u32) -> bool;
}
extern "C" {
    pub fn s2n_constant_time_copy_or_dont(
        dst: *mut u8,
        src: *const u8,
        len: u32,
        dont: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_constant_time_pkcs1_unpad_or_dont(
        dst: *mut u8,
        src: *const u8,
        srclen: u32,
        expectlen: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_mul_overflow(a: u32, b: u32, out: *mut u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Rounds \"initial\" up to a multiple of \"alignment\", and stores the result in \"out\"."]
    #[doc = " Raises an error if overflow would occur."]
    #[doc = " NOT CONSTANT TIME."]
    pub fn s2n_align_to(initial: u32, alignment: u32, out: *mut u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_add_overflow(a: u32, b: u32, out: *mut u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_sub_overflow(a: u32, b: u32, out: *mut u32) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_ecc_named_curve {
    pub iana_id: u16,
    pub libcrypto_nid: ::libc::c_int,
    pub name: *const ::libc::c_char,
    pub share_size: u8,
    pub generate_key: ::core::option::Option<
        unsafe extern "C" fn(
            named_curve: *const s2n_ecc_named_curve,
            evp_pkey: *mut *mut EVP_PKEY,
        ) -> ::libc::c_int,
    >,
}
extern "C" {
    pub static s2n_ecc_curve_secp256r1: s2n_ecc_named_curve;
}
extern "C" {
    pub static s2n_ecc_curve_secp384r1: s2n_ecc_named_curve;
}
extern "C" {
    pub static s2n_ecc_curve_secp521r1: s2n_ecc_named_curve;
}
extern "C" {
    pub static s2n_ecc_curve_x25519: s2n_ecc_named_curve;
}
extern "C" {
    pub static mut s2n_all_supported_curves_list: [*const s2n_ecc_named_curve; 0usize];
}
extern "C" {
    pub static s2n_all_supported_curves_list_len: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_ecc_evp_params {
    pub negotiated_curve: *const s2n_ecc_named_curve,
    pub evp_pkey: *mut EVP_PKEY,
}
extern "C" {
    pub fn s2n_ecc_evp_generate_ephemeral_key(
        ecc_evp_params: *mut s2n_ecc_evp_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_compute_shared_secret_from_params(
        private_ecc_evp_params: *mut s2n_ecc_evp_params,
        public_ecc_evp_params: *mut s2n_ecc_evp_params,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_write_params_point(
        ecc_evp_params: *mut s2n_ecc_evp_params,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_read_params_point(
        in_: *mut s2n_stuffer,
        point_size: ::libc::c_int,
        point_blob: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_compute_shared_secret_as_server(
        server_ecc_evp_params: *mut s2n_ecc_evp_params,
        Yc_in: *mut s2n_stuffer,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_compute_shared_secret_as_client(
        server_ecc_evp_params: *mut s2n_ecc_evp_params,
        Yc_out: *mut s2n_stuffer,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_parse_params_point(
        point_blob: *mut s2n_blob,
        ecc_evp_params: *mut s2n_ecc_evp_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_write_params(
        ecc_evp_params: *mut s2n_ecc_evp_params,
        out: *mut s2n_stuffer,
        written: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_read_params(
        in_: *mut s2n_stuffer,
        data_to_verify: *mut s2n_blob,
        raw_server_ecc_params: *mut s2n_ecdhe_raw_server_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_parse_params(
        raw_server_ecc_params: *mut s2n_ecdhe_raw_server_params,
        ecc_evp_params: *mut s2n_ecc_evp_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_find_supported_curve(
        iana_ids: *mut s2n_blob,
        found: *mut *const s2n_ecc_named_curve,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_evp_params_free(ecc_evp_params: *mut s2n_ecc_evp_params) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_is_evp_apis_supported() -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_ecdsa_key {
    pub ec_key: *mut EC_KEY,
}
pub type s2n_ecdsa_public_key = s2n_ecdsa_key;
pub type s2n_ecdsa_private_key = s2n_ecdsa_key;
extern "C" {
    pub fn s2n_ecdsa_pkey_init(pkey: *mut s2n_pkey) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecdsa_pkey_matches_curve(
        ecdsa_key: *const s2n_ecdsa_key,
        curve: *const s2n_ecc_named_curve,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_evp_pkey_to_ecdsa_public_key(
        ecdsa_key: *mut s2n_ecdsa_public_key,
        pkey: *mut EVP_PKEY,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_evp_pkey_to_ecdsa_private_key(
        ecdsa_key: *mut s2n_ecdsa_private_key,
        pkey: *mut EVP_PKEY,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_rsa_key {
    pub rsa: *mut RSA,
}
pub type s2n_rsa_public_key = s2n_rsa_key;
pub type s2n_rsa_private_key = s2n_rsa_key;
extern "C" {
    pub fn s2n_rsa_pkey_init(pkey: *mut s2n_pkey) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_evp_pkey_to_rsa_public_key(
        rsa_key: *mut s2n_rsa_public_key,
        pkey: *mut EVP_PKEY,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_evp_pkey_to_rsa_private_key(
        rsa_key: *mut s2n_rsa_private_key,
        pkey: *mut EVP_PKEY,
    ) -> ::libc::c_int;
}
pub mod s2n_pkey_type {
    pub type Type = ::libc::c_int;
    pub const S2N_PKEY_TYPE_UNKNOWN: Type = -1;
    pub const S2N_PKEY_TYPE_RSA: Type = 0;
    pub const S2N_PKEY_TYPE_ECDSA: Type = 1;
    pub const S2N_PKEY_TYPE_RSA_PSS: Type = 2;
    pub const S2N_PKEY_TYPE_SENTINEL: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct s2n_pkey {
    pub key: s2n_pkey__bindgen_ty_1,
    pub pkey: *mut EVP_PKEY,
    pub size: ::core::option::Option<
        unsafe extern "C" fn(key: *const s2n_pkey, size_out: *mut u32) -> s2n_result,
    >,
    pub sign: ::core::option::Option<
        unsafe extern "C" fn(
            priv_key: *const s2n_pkey,
            sig_alg: s2n_signature_algorithm::Type,
            digest: *mut s2n_hash_state,
            signature: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub verify: ::core::option::Option<
        unsafe extern "C" fn(
            pub_key: *const s2n_pkey,
            sig_alg: s2n_signature_algorithm::Type,
            digest: *mut s2n_hash_state,
            signature: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *const s2n_pkey,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *const s2n_pkey,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(pub_key: *const s2n_pkey, priv_key: *const s2n_pkey) -> ::libc::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(key: *mut s2n_pkey) -> ::libc::c_int>,
    pub check_key:
        ::core::option::Option<unsafe extern "C" fn(key: *const s2n_pkey) -> ::libc::c_int>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union s2n_pkey__bindgen_ty_1 {
    pub rsa_key: s2n_rsa_key,
    pub ecdsa_key: s2n_ecdsa_key,
}
extern "C" {
    pub fn s2n_pkey_zero_init(pkey: *mut s2n_pkey) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_pkey_setup_for_type(
        pkey: *mut s2n_pkey,
        pkey_type: s2n_pkey_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_pkey_check_key_exists(pkey: *const s2n_pkey) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_pkey_size(pkey: *const s2n_pkey, size_out: *mut u32) -> s2n_result;
}
extern "C" {
    pub fn s2n_pkey_sign(
        pkey: *const s2n_pkey,
        sig_alg: s2n_signature_algorithm::Type,
        digest: *mut s2n_hash_state,
        signature: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_pkey_verify(
        pkey: *const s2n_pkey,
        sig_alg: s2n_signature_algorithm::Type,
        digest: *mut s2n_hash_state,
        signature: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_pkey_encrypt(
        pkey: *const s2n_pkey,
        in_: *mut s2n_blob,
        out: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_pkey_decrypt(
        pkey: *const s2n_pkey,
        in_: *mut s2n_blob,
        out: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_pkey_match(pub_key: *const s2n_pkey, priv_key: *const s2n_pkey) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_pkey_free(pkey: *mut s2n_pkey) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_asn1der_to_private_key(
        priv_key: *mut s2n_pkey,
        asn1der: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_asn1der_to_public_key_and_type(
        pub_key: *mut s2n_pkey,
        pkey_type: *mut s2n_pkey_type::Type,
        asn1der: *mut s2n_blob,
    ) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_cert {
    pub pkey_type: s2n_pkey_type::Type,
    pub public_key: s2n_cert_public_key,
    pub raw: s2n_blob,
    pub next: *mut s2n_cert,
}
#[repr(C)]
pub struct s2n_cert_chain {
    pub chain_size: u32,
    pub head: *mut s2n_cert,
}
#[repr(C)]
pub struct s2n_cert_chain_and_key {
    pub cert_chain: *mut s2n_cert_chain,
    pub private_key: *mut s2n_cert_private_key,
    pub ocsp_status: s2n_blob,
    pub sct_list: s2n_blob,
    pub san_names: *mut s2n_array,
    pub cn_names: *mut s2n_array,
    pub context: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct certs_by_type {
    pub certs: [*mut s2n_cert_chain_and_key; 3usize],
}
extern "C" {
    pub fn s2n_cert_chain_and_key_set_ocsp_data(
        chain_and_key: *mut s2n_cert_chain_and_key,
        data: *const u8,
        length: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_set_sct_list(
        chain_and_key: *mut s2n_cert_chain_and_key,
        data: *const u8,
        length: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_load_cns(
        chain_and_key: *mut s2n_cert_chain_and_key,
        x509_cert: *mut X509,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_load_sans(
        chain_and_key: *mut s2n_cert_chain_and_key,
        x509_cert: *mut X509,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_matches_dns_name(
        chain_and_key: *const s2n_cert_chain_and_key,
        dns_name: *const s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_set_cert_type(
        cert: *mut s2n_cert,
        pkey_type: s2n_pkey_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_send_cert_chain(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
        chain_and_key: *mut s2n_cert_chain_and_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_send_empty_cert_chain(out: *mut s2n_stuffer) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_create_cert_chain_from_stuffer(
        cert_chain_out: *mut s2n_cert_chain,
        chain_in_stuffer: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_set_cert_chain(
        cert_and_key: *mut s2n_cert_chain_and_key,
        cert_chain_pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_set_private_key(
        cert_and_key: *mut s2n_cert_chain_and_key,
        private_key_pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_get_pkey_type(
        chain_and_key: *mut s2n_cert_chain_and_key,
    ) -> s2n_pkey_type::Type;
}
extern "C" {
    pub fn s2n_cert_chain_free(cert_chain: *mut s2n_cert_chain) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_crypto_free(data: *mut *mut u8) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_session_key {
    pub evp_cipher_ctx: *mut EVP_CIPHER_CTX,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_stream_cipher {
    pub decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
}
#[repr(C)]
pub struct s2n_cbc_cipher {
    pub block_size: u8,
    pub record_iv_size: u8,
    pub decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            iv: *mut s2n_blob,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            iv: *mut s2n_blob,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
}
#[repr(C)]
pub struct s2n_aead_cipher {
    pub fixed_iv_size: u8,
    pub record_iv_size: u8,
    pub tag_size: u8,
    pub decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            iv: *mut s2n_blob,
            add: *mut s2n_blob,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            iv: *mut s2n_blob,
            add: *mut s2n_blob,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
}
#[repr(C)]
pub struct s2n_composite_cipher {
    pub block_size: u8,
    pub record_iv_size: u8,
    pub mac_key_size: u8,
    pub decrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            iv: *mut s2n_blob,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub encrypt: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            iv: *mut s2n_blob,
            in_: *mut s2n_blob,
            out: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub set_mac_write_key: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            mac_key: *mut u8,
            mac_size: u32,
        ) -> ::libc::c_int,
    >,
    pub initial_hmac: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut s2n_session_key,
            sequence_number: *mut u8,
            content_type: u8,
            protocol_version: u16,
            payload_and_eiv_len: u16,
            extra: *mut ::libc::c_int,
        ) -> ::libc::c_int,
    >,
}
#[repr(C)]
pub struct s2n_cipher {
    pub type_: s2n_cipher__bindgen_ty_1::Type,
    pub io: s2n_cipher__bindgen_ty_2,
    pub key_material_size: u8,
    pub is_available: ::core::option::Option<unsafe extern "C" fn() -> u8>,
    pub init:
        ::core::option::Option<unsafe extern "C" fn(key: *mut s2n_session_key) -> ::libc::c_int>,
    pub set_decryption_key: ::core::option::Option<
        unsafe extern "C" fn(key: *mut s2n_session_key, in_: *mut s2n_blob) -> ::libc::c_int,
    >,
    pub set_encryption_key: ::core::option::Option<
        unsafe extern "C" fn(key: *mut s2n_session_key, in_: *mut s2n_blob) -> ::libc::c_int,
    >,
    pub destroy_key:
        ::core::option::Option<unsafe extern "C" fn(key: *mut s2n_session_key) -> ::libc::c_int>,
}
pub mod s2n_cipher__bindgen_ty_1 {
    pub type Type = ::libc::c_uint;
    pub const S2N_STREAM: Type = 0;
    pub const S2N_CBC: Type = 1;
    pub const S2N_AEAD: Type = 2;
    pub const S2N_COMPOSITE: Type = 3;
}
#[repr(C)]
pub struct s2n_cipher__bindgen_ty_2 {
    pub stream: __BindgenUnionField<s2n_stream_cipher>,
    pub aead: __BindgenUnionField<s2n_aead_cipher>,
    pub cbc: __BindgenUnionField<s2n_cbc_cipher>,
    pub comp: __BindgenUnionField<s2n_composite_cipher>,
    pub bindgen_union_field: [u64; 5usize],
}
extern "C" {
    pub fn s2n_session_key_alloc(key: *mut s2n_session_key) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_session_key_free(key: *mut s2n_session_key) -> ::libc::c_int;
}
extern "C" {
    pub static mut s2n_null_cipher: s2n_cipher;
}
extern "C" {
    pub static mut s2n_rc4: s2n_cipher;
}
extern "C" {
    pub static mut s2n_aes128: s2n_cipher;
}
extern "C" {
    pub static mut s2n_aes256: s2n_cipher;
}
extern "C" {
    pub static mut s2n_3des: s2n_cipher;
}
extern "C" {
    pub static mut s2n_aes128_gcm: s2n_cipher;
}
extern "C" {
    pub static mut s2n_aes256_gcm: s2n_cipher;
}
extern "C" {
    pub static mut s2n_aes128_sha: s2n_cipher;
}
extern "C" {
    pub static mut s2n_aes256_sha: s2n_cipher;
}
extern "C" {
    pub static mut s2n_aes128_sha256: s2n_cipher;
}
extern "C" {
    pub static mut s2n_aes256_sha256: s2n_cipher;
}
extern "C" {
    pub static mut s2n_chacha20_poly1305: s2n_cipher;
}
extern "C" {
    pub static mut s2n_tls13_aes128_gcm: s2n_cipher;
}
extern "C" {
    pub static mut s2n_tls13_aes256_gcm: s2n_cipher;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_dh_params {
    pub dh: *mut DH,
}
extern "C" {
    pub fn s2n_pkcs3_to_dh_params(
        dh_params: *mut s2n_dh_params,
        pkcs3: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dh_p_g_Ys_to_dh_params(
        server_dh_params: *mut s2n_dh_params,
        p: *mut s2n_blob,
        g: *mut s2n_blob,
        ys: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dh_params_to_p_g_Ys(
        server_dh_params: *mut s2n_dh_params,
        out: *mut s2n_stuffer,
        output: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dh_compute_shared_secret_as_server(
        server_dh_params: *mut s2n_dh_params,
        Yc_in: *mut s2n_stuffer,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dh_compute_shared_secret_as_client(
        server_dh_params: *mut s2n_dh_params,
        Yc_out: *mut s2n_stuffer,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dh_params_copy(from: *mut s2n_dh_params, to: *mut s2n_dh_params) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dh_params_check(dh_params: *mut s2n_dh_params) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dh_generate_ephemeral_key(dh_params: *mut s2n_dh_params) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dh_params_free(dh_params: *mut s2n_dh_params) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_drbg {
    pub bytes_used: u64,
    pub ctx: *mut EVP_CIPHER_CTX,
    pub v: [u8; 16usize],
    pub mixes: u64,
}
pub mod s2n_drbg_mode {
    pub type Type = ::libc::c_uint;
    pub const S2N_AES_128_CTR_NO_DF_PR: Type = 0;
    pub const S2N_AES_256_CTR_NO_DF_PR: Type = 1;
}
extern "C" {
    pub fn s2n_drbg_instantiate(
        drbg: *mut s2n_drbg,
        personalization_string: *mut s2n_blob,
        mode: s2n_drbg_mode::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_drbg_generate(drbg: *mut s2n_drbg, returned_bits: *mut s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_drbg_wipe(drbg: *mut s2n_drbg) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_drbg_bytes_used(drbg: *mut s2n_drbg, bytes_used: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_fips_init() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_is_in_fips_mode() -> ::libc::c_int;
}
pub mod s2n_hmac_algorithm {
    pub type Type = ::libc::c_uint;
    pub const S2N_HMAC_NONE: Type = 0;
    pub const S2N_HMAC_MD5: Type = 1;
    pub const S2N_HMAC_SHA1: Type = 2;
    pub const S2N_HMAC_SHA224: Type = 3;
    pub const S2N_HMAC_SHA256: Type = 4;
    pub const S2N_HMAC_SHA384: Type = 5;
    pub const S2N_HMAC_SHA512: Type = 6;
    pub const S2N_HMAC_SSLv3_MD5: Type = 7;
    pub const S2N_HMAC_SSLv3_SHA1: Type = 8;
}
#[repr(C)]
pub struct s2n_hmac_state {
    pub alg: s2n_hmac_algorithm::Type,
    pub hash_block_size: u16,
    pub currently_in_hash_block: u32,
    pub xor_pad_size: u16,
    pub digest_size: u8,
    pub inner: s2n_hash_state,
    pub inner_just_key: s2n_hash_state,
    pub outer: s2n_hash_state,
    pub outer_just_key: s2n_hash_state,
    pub xor_pad: [u8; 128usize],
    pub digest_pad: [u8; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_hmac_evp_backup {
    pub inner: s2n_hash_evp_digest,
    pub inner_just_key: s2n_hash_evp_digest,
    pub outer: s2n_hash_evp_digest,
    pub outer_just_key: s2n_hash_evp_digest,
}
extern "C" {
    pub fn s2n_hmac_digest_size(alg: s2n_hmac_algorithm::Type, out: *mut u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_is_available(alg: s2n_hmac_algorithm::Type) -> bool;
}
extern "C" {
    pub fn s2n_hmac_hash_alg(
        hmac_alg: s2n_hmac_algorithm::Type,
        out: *mut s2n_hash_algorithm::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hash_hmac_alg(
        hash_alg: s2n_hash_algorithm::Type,
        out: *mut s2n_hmac_algorithm::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_new(state: *mut s2n_hmac_state) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_hmac_state_validate(state: *mut s2n_hmac_state) -> s2n_result;
}
extern "C" {
    pub fn s2n_hmac_init(
        state: *mut s2n_hmac_state,
        alg: s2n_hmac_algorithm::Type,
        key: *const ::libc::c_void,
        klen: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_update(
        state: *mut s2n_hmac_state,
        in_: *const ::libc::c_void,
        size: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_digest(
        state: *mut s2n_hmac_state,
        out: *mut ::libc::c_void,
        size: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_digest_two_compression_rounds(
        state: *mut s2n_hmac_state,
        out: *mut ::libc::c_void,
        size: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_digest_verify(
        a: *const ::libc::c_void,
        b: *const ::libc::c_void,
        len: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_free(state: *mut s2n_hmac_state) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_reset(state: *mut s2n_hmac_state) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_copy(to: *mut s2n_hmac_state, from: *mut s2n_hmac_state) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_save_evp_hash_state(
        backup: *mut s2n_hmac_evp_backup,
        hmac: *mut s2n_hmac_state,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hmac_restore_evp_hash_state(
        backup: *mut s2n_hmac_evp_backup,
        hmac: *mut s2n_hmac_state,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hkdf(
        hmac: *mut s2n_hmac_state,
        alg: s2n_hmac_algorithm::Type,
        salt: *const s2n_blob,
        key: *const s2n_blob,
        info: *const s2n_blob,
        output: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hkdf_extract(
        hmac: *mut s2n_hmac_state,
        alg: s2n_hmac_algorithm::Type,
        salt: *const s2n_blob,
        key: *const s2n_blob,
        pseudo_rand_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hkdf_expand_label(
        hmac: *mut s2n_hmac_state,
        alg: s2n_hmac_algorithm::Type,
        secret: *const s2n_blob,
        label: *const s2n_blob,
        context: *const s2n_blob,
        output: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_openssl_x509_stack_pop_free(cert_chain: *mut *mut stack_st_X509) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_rsa_pkcs1v15_sign(
        priv_: *const s2n_pkey,
        digest: *mut s2n_hash_state,
        signature: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_rsa_pkcs1v15_verify(
        pub_: *const s2n_pkey,
        digest: *mut s2n_hash_state,
        signature: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_rsa_pss_sign(
        priv_: *const s2n_pkey,
        digest: *mut s2n_hash_state,
        signature_out: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_rsa_pss_verify(
        pub_: *const s2n_pkey,
        digest: *mut s2n_hash_state,
        signature_in: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_is_rsa_pss_signing_supported() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_is_rsa_pss_certs_supported() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_rsa_pss_pkey_init(pkey: *mut s2n_pkey) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_evp_pkey_to_rsa_pss_public_key(
        rsa_key: *mut s2n_rsa_key,
        pkey: *mut EVP_PKEY,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_evp_pkey_to_rsa_pss_private_key(
        rsa_key: *mut s2n_rsa_key,
        pkey: *mut EVP_PKEY,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_increment_sequence_number(sequence_number: *mut s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_sequence_number_to_uint64(
        sequence_number: *mut s2n_blob,
        output: *mut u64,
    ) -> ::libc::c_int;
}
pub mod s2n_early_data_state {
    pub type Type = ::libc::c_uint;
    pub const S2N_UNKNOWN_EARLY_DATA_STATE: Type = 0;
    pub const S2N_EARLY_DATA_REQUESTED: Type = 1;
    pub const S2N_EARLY_DATA_NOT_REQUESTED: Type = 2;
    pub const S2N_EARLY_DATA_ACCEPTED: Type = 3;
    pub const S2N_EARLY_DATA_REJECTED: Type = 4;
    pub const S2N_END_OF_EARLY_DATA: Type = 5;
    pub const S2N_EARLY_DATA_STATES_COUNT: Type = 6;
}
extern "C" {
    #[must_use]
    pub fn s2n_connection_set_early_data_state(
        conn: *mut s2n_connection,
        state: s2n_early_data_state::Type,
    ) -> s2n_result;
}
#[repr(C)]
pub struct s2n_early_data_config {
    pub max_early_data_size: u32,
    pub protocol_version: u8,
    pub cipher_suite: *mut s2n_cipher_suite,
    pub application_protocol: s2n_blob,
    pub context: s2n_blob,
}
extern "C" {
    pub fn s2n_early_data_config_free(config: *mut s2n_early_data_config) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_early_data_config_clone(
        new_psk: *mut s2n_psk,
        old_config: *mut s2n_early_data_config,
    ) -> s2n_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_offered_early_data {
    pub conn: *mut s2n_connection,
}
extern "C" {
    pub fn s2n_early_data_is_valid_for_connection(conn: *mut s2n_connection) -> bool;
}
extern "C" {
    #[must_use]
    pub fn s2n_early_data_accept_or_reject(conn: *mut s2n_connection) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_early_data_get_server_max_size(
        conn: *mut s2n_connection,
        max_early_data_size: *mut u32,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_early_data_record_bytes(conn: *mut s2n_connection, data_len: isize) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_early_data_validate_send(
        conn: *mut s2n_connection,
        bytes_to_send: u32,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_early_data_validate_recv(conn: *mut s2n_connection) -> s2n_result;
}
extern "C" {
    pub fn s2n_config_set_server_max_early_data_size(
        config: *mut s2n_config,
        max_early_data_size: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_server_max_early_data_size(
        conn: *mut s2n_connection,
        max_early_data_size: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_server_early_data_context(
        conn: *mut s2n_connection,
        context: *const u8,
        context_size: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_psk_configure_early_data(
        psk: *mut s2n_psk,
        max_early_data_size: u32,
        cipher_suite_first_byte: u8,
        cipher_suite_second_byte: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_psk_set_application_protocol(
        psk: *mut s2n_psk,
        application_protocol: *const u8,
        size: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_psk_set_context(psk: *mut s2n_psk, context: *const u8, size: u16) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_early_data_expected(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_end_of_early_data(conn: *mut s2n_connection) -> ::libc::c_int;
}
pub mod s2n_early_data_status_t {
    pub type Type = ::libc::c_uint;
    pub const S2N_EARLY_DATA_STATUS_OK: Type = 0;
    pub const S2N_EARLY_DATA_STATUS_NOT_REQUESTED: Type = 1;
    pub const S2N_EARLY_DATA_STATUS_REJECTED: Type = 2;
    pub const S2N_EARLY_DATA_STATUS_END: Type = 3;
}
extern "C" {
    pub fn s2n_connection_get_early_data_status(
        conn: *mut s2n_connection,
        status: *mut s2n_early_data_status_t::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_remaining_early_data_size(
        conn: *mut s2n_connection,
        allowed_early_data_size: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_max_early_data_size(
        conn: *mut s2n_connection,
        max_early_data_size: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_send_early_data(
        conn: *mut s2n_connection,
        data: *const u8,
        data_len: isize,
        data_sent: *mut isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_early_data(
        conn: *mut s2n_connection,
        data: *mut u8,
        max_data_len: isize,
        data_received: *mut isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
pub type s2n_early_data_cb = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        early_data: *mut s2n_offered_early_data,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_config_set_early_data_cb(
        config: *mut s2n_config,
        cb: s2n_early_data_cb,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_offered_early_data_get_context_length(
        early_data: *mut s2n_offered_early_data,
        context_len: *mut u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_offered_early_data_get_context(
        early_data: *mut s2n_offered_early_data,
        context: *mut u8,
        max_len: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_offered_early_data_reject(early_data: *mut s2n_offered_early_data) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_offered_early_data_accept(early_data: *mut s2n_offered_early_data) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_array {
    pub mem: s2n_blob,
    pub len: u32,
    pub element_size: u32,
}
extern "C" {
    #[must_use]
    pub fn s2n_array_validate(array: *const s2n_array) -> s2n_result;
}
extern "C" {
    pub fn s2n_array_new(element_size: u32) -> *mut s2n_array;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_init(array: *mut s2n_array, element_size: u32) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_pushback(
        array: *mut s2n_array,
        element: *mut *mut ::libc::c_void,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_get(
        array: *mut s2n_array,
        idx: u32,
        element: *mut *mut ::libc::c_void,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_insert(
        array: *mut s2n_array,
        idx: u32,
        element: *mut *mut ::libc::c_void,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_insert_and_copy(
        array: *mut s2n_array,
        idx: u32,
        element: *mut ::libc::c_void,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_num_elements(array: *mut s2n_array, len: *mut u32) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_capacity(array: *mut s2n_array, capacity: *mut u32) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_remove(array: *mut s2n_array, idx: u32) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_free_p(parray: *mut *mut s2n_array) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_array_free(array: *mut s2n_array) -> s2n_result;
}
pub mod s2n_psk_type {
    pub type Type = ::libc::c_uint;
    pub const S2N_PSK_TYPE_RESUMPTION: Type = 0;
    pub const S2N_PSK_TYPE_EXTERNAL: Type = 1;
}
pub mod s2n_psk_key_exchange_mode {
    pub type Type = ::libc::c_uint;
    pub const S2N_PSK_KE_UNKNOWN: Type = 0;
    pub const S2N_PSK_KE: Type = 1;
    pub const S2N_PSK_DHE_KE: Type = 2;
}
#[repr(C)]
pub struct s2n_psk {
    pub type_: s2n_psk_type::Type,
    pub identity: s2n_blob,
    pub secret: s2n_blob,
    pub hmac_alg: s2n_hmac_algorithm::Type,
    pub ticket_age_add: u32,
    pub ticket_issue_time: u64,
    pub early_secret: s2n_blob,
    pub early_data_config: s2n_early_data_config,
    pub keying_material_expiration: u64,
}
extern "C" {
    #[must_use]
    pub fn s2n_psk_init(psk: *mut s2n_psk, type_: s2n_psk_type::Type) -> s2n_result;
}
extern "C" {
    pub fn s2n_psk_wipe(psk: *mut s2n_psk) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_psk_clone(new_psk: *mut s2n_psk, original_psk: *mut s2n_psk) -> s2n_result;
}
#[repr(C)]
pub struct s2n_psk_parameters {
    pub type_: s2n_psk_type::Type,
    pub psk_list: s2n_array,
    pub binder_list_size: u16,
    pub chosen_psk_wire_index: u16,
    pub chosen_psk: *mut s2n_psk,
    pub psk_ke_mode: s2n_psk_key_exchange_mode::Type,
}
extern "C" {
    #[must_use]
    pub fn s2n_psk_parameters_init(params: *mut s2n_psk_parameters) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_psk_parameters_offered_psks_size(
        params: *mut s2n_psk_parameters,
        size: *mut u32,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_psk_parameters_wipe(params: *mut s2n_psk_parameters) -> s2n_result;
}
extern "C" {
    pub fn s2n_psk_parameters_wipe_secrets(params: *mut s2n_psk_parameters) -> s2n_result;
}
#[repr(C)]
pub struct s2n_offered_psk {
    pub identity: s2n_blob,
    pub wire_index: u16,
    pub obfuscated_ticket_age: u32,
}
#[repr(C)]
pub struct s2n_offered_psk_list {
    pub conn: *mut s2n_connection,
    pub wire_data: s2n_stuffer,
    pub wire_index: u16,
}
extern "C" {
    #[must_use]
    pub fn s2n_finish_psk_extension(conn: *mut s2n_connection) -> s2n_result;
}
extern "C" {
    pub fn s2n_psk_calculate_binder_hash(
        conn: *mut s2n_connection,
        hmac_alg: s2n_hmac_algorithm::Type,
        partial_client_hello: *const s2n_blob,
        output_binder_hash: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_psk_calculate_binder(
        psk: *mut s2n_psk,
        binder_hash: *const s2n_blob,
        output_binder: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_psk_verify_binder(
        conn: *mut s2n_connection,
        psk: *mut s2n_psk,
        partial_client_hello: *const s2n_blob,
        binder_to_verify: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_connection_set_psk_type(
        conn: *mut s2n_connection,
        type_: s2n_psk_type::Type,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_psk_validate_keying_material(conn: *mut s2n_connection) -> s2n_result;
}
pub mod s2n_psk_hmac {
    pub type Type = ::libc::c_uint;
    pub const S2N_PSK_HMAC_SHA256: Type = 0;
    pub const S2N_PSK_HMAC_SHA384: Type = 1;
}
extern "C" {
    pub fn s2n_external_psk_new() -> *mut s2n_psk;
}
extern "C" {
    pub fn s2n_psk_free(psk: *mut *mut s2n_psk) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_psk_set_identity(
        psk: *mut s2n_psk,
        identity: *const u8,
        identity_size: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_psk_set_secret(
        psk: *mut s2n_psk,
        secret: *const u8,
        secret_size: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_psk_set_hmac(psk: *mut s2n_psk, hmac: s2n_psk_hmac::Type) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_append_psk(conn: *mut s2n_connection, psk: *mut s2n_psk)
        -> ::libc::c_int;
}
pub mod s2n_psk_mode {
    pub type Type = ::libc::c_uint;
    pub const S2N_PSK_MODE_RESUMPTION: Type = 0;
    pub const S2N_PSK_MODE_EXTERNAL: Type = 1;
}
extern "C" {
    pub fn s2n_config_set_psk_mode(
        config: *mut s2n_config,
        mode: s2n_psk_mode::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_psk_mode(
        conn: *mut s2n_connection,
        mode: s2n_psk_mode::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_negotiated_psk_identity_length(
        conn: *mut s2n_connection,
        identity_length: *mut u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_negotiated_psk_identity(
        conn: *mut s2n_connection,
        identity: *mut u8,
        max_identity_length: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_offered_psk_new() -> *mut s2n_offered_psk;
}
extern "C" {
    pub fn s2n_offered_psk_free(psk: *mut *mut s2n_offered_psk) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_offered_psk_get_identity(
        psk: *mut s2n_offered_psk,
        identity: *mut *mut u8,
        size: *mut u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_offered_psk_list_has_next(psk_list: *mut s2n_offered_psk_list) -> bool;
}
extern "C" {
    pub fn s2n_offered_psk_list_next(
        psk_list: *mut s2n_offered_psk_list,
        psk: *mut s2n_offered_psk,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_offered_psk_list_reread(psk_list: *mut s2n_offered_psk_list) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_offered_psk_list_choose_psk(
        psk_list: *mut s2n_offered_psk_list,
        psk: *mut s2n_offered_psk,
    ) -> ::libc::c_int;
}
pub type s2n_psk_selection_callback = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        context: *mut ::libc::c_void,
        psk_list: *mut s2n_offered_psk_list,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_config_set_psk_selection_callback(
        config: *mut s2n_config,
        cb: s2n_psk_selection_callback,
        context: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_mem_init() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_mem_is_init() -> bool;
}
extern "C" {
    pub fn s2n_mem_get_page_size() -> u32;
}
extern "C" {
    pub fn s2n_mem_cleanup() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_alloc(b: *mut s2n_blob, size: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_realloc(b: *mut s2n_blob, size: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_free(b: *mut s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_blob_zeroize_free(b: *mut s2n_blob) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_free_object(p_data: *mut *mut u8, size: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dup(from: *mut s2n_blob, to: *mut s2n_blob) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_tls13_keys {
    pub hmac_algorithm: s2n_hmac_algorithm::Type,
    pub hash_algorithm: s2n_hash_algorithm::Type,
    pub size: u8,
    pub extract_secret: s2n_blob,
    pub derive_secret: s2n_blob,
    pub extract_secret_bytes: [u8; 48usize],
    pub derive_secret_bytes: [u8; 48usize],
    pub hmac: s2n_hmac_state,
}
extern "C" {
    pub static s2n_tls13_label_derived_secret: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_external_psk_binder_key: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_resumption_psk_binder_key: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_client_early_traffic_secret: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_early_exporter_master_secret: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_client_handshake_traffic_secret: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_server_handshake_traffic_secret: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_client_application_traffic_secret: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_server_application_traffic_secret: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_exporter_master_secret: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_resumption_master_secret: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_traffic_secret_key: s2n_blob;
}
extern "C" {
    pub static s2n_tls13_label_traffic_secret_iv: s2n_blob;
}
extern "C" {
    pub fn s2n_tls13_keys_init(
        handshake: *mut s2n_tls13_keys,
        alg: s2n_hmac_algorithm::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_keys_free(keys: *mut s2n_tls13_keys) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_derive_binder_key(
        keys: *mut s2n_tls13_keys,
        psk: *mut s2n_psk,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_derive_early_secret(
        handshake: *mut s2n_tls13_keys,
        psk: *mut s2n_psk,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_derive_early_traffic_secret(
        keys: *mut s2n_tls13_keys,
        client_hello_hash: *mut s2n_hash_state,
        secret: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_extract_handshake_secret(
        keys: *mut s2n_tls13_keys,
        ecdhe: *const s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_derive_handshake_traffic_secret(
        keys: *mut s2n_tls13_keys,
        client_server_hello_hash: *mut s2n_hash_state,
        secret: *mut s2n_blob,
        mode: s2n_mode::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_extract_master_secret(handshake: *mut s2n_tls13_keys) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_derive_application_secret(
        handshake: *mut s2n_tls13_keys,
        hashes: *mut s2n_hash_state,
        secret_blob: *mut s2n_blob,
        mode: s2n_mode::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_derive_traffic_keys(
        handshake: *mut s2n_tls13_keys,
        secret: *mut s2n_blob,
        key: *mut s2n_blob,
        iv: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_derive_finished_key(
        keys: *mut s2n_tls13_keys,
        secret_key: *mut s2n_blob,
        output_finish_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_calculate_finished_mac(
        keys: *mut s2n_tls13_keys,
        finished_key: *mut s2n_blob,
        hash_state: *mut s2n_hash_state,
        finished_verify: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_update_application_traffic_secret(
        keys: *mut s2n_tls13_keys,
        old_secret: *mut s2n_blob,
        new_secret: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_derive_resumption_master_secret(
        keys: *mut s2n_tls13_keys,
        hashes: *mut s2n_hash_state,
        secret_blob: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_tls13_derive_session_ticket_secret(
        keys: *mut s2n_tls13_keys,
        resumption_secret: *mut s2n_blob,
        ticket_nonce: *mut s2n_blob,
        secret_blob: *mut s2n_blob,
    ) -> s2n_result;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
pub struct s2n_extension_type {
    pub iana_value: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub minimum_version: u16,
    pub send: ::core::option::Option<
        unsafe extern "C" fn(conn: *mut s2n_connection, out: *mut s2n_stuffer) -> ::libc::c_int,
    >,
    pub recv: ::core::option::Option<
        unsafe extern "C" fn(conn: *mut s2n_connection, in_: *mut s2n_stuffer) -> ::libc::c_int,
    >,
    pub should_send:
        ::core::option::Option<unsafe extern "C" fn(conn: *mut s2n_connection) -> bool>,
    pub if_missing:
        ::core::option::Option<unsafe extern "C" fn(conn: *mut s2n_connection) -> ::libc::c_int>,
}
impl s2n_extension_type {
    #[inline]
    pub fn is_response(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_response(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_response: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_response: u32 = unsafe { ::core::mem::transmute(is_response) };
            is_response as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static s2n_supported_extensions: [u16; 18usize];
}
pub type s2n_extension_bitfield = [::libc::c_char; 19usize];
pub type s2n_extension_type_id = u8;
extern "C" {
    pub static s2n_unsupported_extension: s2n_extension_type_id;
}
extern "C" {
    pub fn s2n_extension_send(
        extension_type: *const s2n_extension_type,
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_recv(
        extension_type: *const s2n_extension_type,
        conn: *mut s2n_connection,
        in_: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_is_missing(
        extension_type: *const s2n_extension_type,
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_supported_iana_value_to_id(
        iana_value: u16,
        internal_id: *mut s2n_extension_type_id,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_type_init() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_send_unimplemented(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_send_noop(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_recv_unimplemented(
        conn: *mut s2n_connection,
        in_: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_recv_noop(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_always_send(conn: *mut s2n_connection) -> bool;
}
extern "C" {
    pub fn s2n_extension_never_send(conn: *mut s2n_connection) -> bool;
}
extern "C" {
    pub fn s2n_extension_send_if_tls13_connection(conn: *mut s2n_connection) -> bool;
}
extern "C" {
    pub fn s2n_extension_error_if_missing(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_noop_if_missing(conn: *mut s2n_connection) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_parsed_extension {
    pub extension_type: u16,
    pub extension: s2n_blob,
    pub wire_index: u16,
}
#[repr(C)]
pub struct s2n_parsed_extensions_list {
    pub parsed_extensions: [s2n_parsed_extension; 18usize],
    pub raw: s2n_blob,
    pub count: u16,
}
pub mod s2n_extension_list_id {
    pub type Type = ::libc::c_uint;
    pub const S2N_EXTENSION_LIST_CLIENT_HELLO: Type = 0;
    pub const S2N_EXTENSION_LIST_HELLO_RETRY_REQUEST: Type = 1;
    pub const S2N_EXTENSION_LIST_SERVER_HELLO_DEFAULT: Type = 2;
    pub const S2N_EXTENSION_LIST_SERVER_HELLO_TLS13: Type = 3;
    pub const S2N_EXTENSION_LIST_ENCRYPTED_EXTENSIONS: Type = 4;
    pub const S2N_EXTENSION_LIST_CERT_REQ: Type = 5;
    pub const S2N_EXTENSION_LIST_CERTIFICATE: Type = 6;
    pub const S2N_EXTENSION_LIST_NST: Type = 7;
    pub const S2N_EXTENSION_LIST_EMPTY: Type = 8;
    pub const S2N_EXTENSION_LIST_IDS_COUNT: Type = 9;
}
extern "C" {
    pub fn s2n_extension_list_send(
        list_type: s2n_extension_list_id::Type,
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_list_recv(
        list_type: s2n_extension_list_id::Type,
        conn: *mut s2n_connection,
        in_: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_process(
        extension_type: *const s2n_extension_type,
        conn: *mut s2n_connection,
        parsed_extension_list: *mut s2n_parsed_extensions_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_list_process(
        list_type: s2n_extension_list_id::Type,
        conn: *mut s2n_connection,
        parsed_extension_list: *mut s2n_parsed_extensions_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extension_list_parse(
        in_: *mut s2n_stuffer,
        parsed_extension_list: *mut s2n_parsed_extensions_list,
    ) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_client_hello {
    pub raw_message: s2n_stuffer,
    pub extensions: s2n_parsed_extensions_list,
    pub cipher_suites: s2n_blob,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl s2n_client_hello {
    #[inline]
    pub fn callback_invoked(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_callback_invoked(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn callback_async_blocked(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_callback_async_blocked(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn callback_async_done(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_callback_async_done(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        callback_invoked: ::libc::c_uint,
        callback_async_blocked: ::libc::c_uint,
        callback_async_done: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let callback_invoked: u32 = unsafe { ::core::mem::transmute(callback_invoked) };
            callback_invoked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let callback_async_blocked: u32 =
                unsafe { ::core::mem::transmute(callback_async_blocked) };
            callback_async_blocked as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let callback_async_done: u32 = unsafe { ::core::mem::transmute(callback_async_done) };
            callback_async_done as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn s2n_client_hello_free(client_hello: *mut s2n_client_hello) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_ticket_key {
    pub key_name: [::libc::c_uchar; 16usize],
    pub aes_key: [u8; 32usize],
    pub implicit_aad: [u8; 12usize],
    pub intro_timestamp: u64,
}
#[repr(C)]
pub struct s2n_ticket_key_weight {
    pub key_weight: f64,
    pub key_index: u8,
}
#[repr(C)]
pub struct s2n_ticket_fields {
    pub session_secret: s2n_blob,
    pub ticket_age_add: u32,
}
#[repr(C)]
pub struct s2n_session_ticket {
    pub ticket_data: s2n_blob,
    pub session_lifetime: u32,
}
extern "C" {
    pub fn s2n_find_ticket_key(config: *mut s2n_config, name: *const u8) -> *mut s2n_ticket_key;
}
extern "C" {
    pub fn s2n_encrypt_session_ticket(
        conn: *mut s2n_connection,
        to: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_decrypt_session_ticket(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_encrypt_session_cache(
        conn: *mut s2n_connection,
        to: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_decrypt_session_cache(
        conn: *mut s2n_connection,
        from: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_is_encrypt_decrypt_key_available(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_verify_unique_ticket_key(
        config: *mut s2n_config,
        hash: *mut u8,
        insert_index: *mut u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_wipe_expired_ticket_crypto_keys(
        config: *mut s2n_config,
        expired_key_index: i8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_store_ticket_key(
        config: *mut s2n_config,
        key: *mut s2n_ticket_key,
    ) -> ::libc::c_int;
}
pub mod s2n_client_tls_session_state_format {
    pub type Type = ::libc::c_uint;
    pub const S2N_STATE_WITH_SESSION_ID: Type = 0;
    pub const S2N_STATE_WITH_SESSION_TICKET: Type = 1;
}
pub mod s2n_serial_format_version {
    pub type Type = ::libc::c_uint;
    pub const S2N_TLS12_SERIALIZED_FORMAT_VERSION: Type = 1;
    pub const S2N_TLS13_SERIALIZED_FORMAT_VERSION: Type = 2;
}
extern "C" {
    pub fn s2n_allowed_to_cache_connection(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_resume_from_cache(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_store_to_cache(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_connection_get_session_state_size(
        conn: *mut s2n_connection,
        state_size: *mut usize,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_config_set_initial_ticket_count(config: *mut s2n_config, num: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_add_new_tickets_to_send(
        conn: *mut s2n_connection,
        num: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_server_keying_material_lifetime(
        conn: *mut s2n_connection,
        lifetime_in_secs: u32,
    ) -> ::libc::c_int;
}
pub type s2n_session_ticket_fn = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        ctx: *mut ::libc::c_void,
        ticket: *mut s2n_session_ticket,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_config_set_session_ticket_cb(
        config: *mut s2n_config,
        callback: s2n_session_ticket_fn,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_session_ticket_get_data_len(
        ticket: *mut s2n_session_ticket,
        data_len: *mut usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_session_ticket_get_data(
        ticket: *mut s2n_session_ticket,
        max_data_len: usize,
        data: *mut u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_session_ticket_get_lifetime(
        ticket: *mut s2n_session_ticket,
        session_lifetime: *mut u32,
    ) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_signature_scheme {
    pub iana_value: u16,
    pub hash_alg: s2n_hash_algorithm::Type,
    pub sig_alg: s2n_signature_algorithm::Type,
    pub minimum_protocol_version: u8,
    pub maximum_protocol_version: u8,
    pub libcrypto_nid: u16,
    pub signature_curve: *const s2n_ecc_named_curve,
}
#[repr(C)]
pub struct s2n_signature_preferences {
    pub count: u8,
    pub signature_schemes: *const *const s2n_signature_scheme,
}
extern "C" {
    pub static s2n_rsa_pkcs1_md5_sha1: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pkcs1_sha1: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pkcs1_sha224: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pkcs1_sha256: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pkcs1_sha384: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pkcs1_sha512: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_ecdsa_sha1: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_ecdsa_sha224: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_ecdsa_sha256: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_ecdsa_sha384: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_ecdsa_sha512: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_ecdsa_secp256r1_sha256: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_ecdsa_secp384r1_sha384: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_ecdsa_secp521r1_sha512: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pss_pss_sha256: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pss_pss_sha384: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pss_pss_sha512: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pss_rsae_sha256: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pss_rsae_sha384: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_rsa_pss_rsae_sha512: s2n_signature_scheme;
}
extern "C" {
    pub static s2n_signature_preferences_20140601: s2n_signature_preferences;
}
extern "C" {
    pub static s2n_signature_preferences_20200207: s2n_signature_preferences;
}
extern "C" {
    pub static s2n_signature_preferences_20201021: s2n_signature_preferences;
}
extern "C" {
    pub static s2n_signature_preferences_null: s2n_signature_preferences;
}
extern "C" {
    pub static s2n_certificate_signature_preferences_20201110: s2n_signature_preferences;
}
pub mod s2n_cert_validation_code {
    pub type Type = ::libc::c_int;
    pub const S2N_CERT_OK: Type = 0;
    pub const S2N_CERT_ERR_UNTRUSTED: Type = -1;
    pub const S2N_CERT_ERR_REVOKED: Type = -2;
    pub const S2N_CERT_ERR_EXPIRED: Type = -3;
    pub const S2N_CERT_ERR_TYPE_UNSUPPORTED: Type = -4;
    pub const S2N_CERT_ERR_INVALID: Type = -5;
    pub const S2N_CERT_ERR_MAX_CHAIN_DEPTH_EXCEEDED: Type = -6;
}
#[doc = " Trust store simply contains the trust store each connection should validate certs against."]
#[doc = " For most use cases, you only need one of these per application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_x509_trust_store {
    pub trust_store: *mut X509_STORE,
}
#[doc = " You should have one instance of this per connection."]
#[repr(C)]
pub struct s2n_x509_validator {
    pub trust_store: *mut s2n_x509_trust_store,
    pub store_ctx: *mut X509_STORE_CTX,
    pub skip_cert_validation: u8,
    pub check_stapled_ocsp: u8,
    pub max_chain_depth: u16,
    pub cert_chain_from_wire: *mut stack_st_X509,
    pub state: ::libc::c_int,
}
extern "C" {
    #[doc = " Some libcrypto implementations do not support OCSP validation. Returns 1 if supported, 0 otherwise."]
    pub fn s2n_x509_ocsp_stapling_supported() -> u8;
}
extern "C" {
    #[doc = " Initialize the trust store to empty defaults (no allocations happen here)"]
    pub fn s2n_x509_trust_store_init_empty(store: *mut s2n_x509_trust_store);
}
extern "C" {
    #[doc = " Returns TRUE if the trust store has certificates installed, FALSE otherwise"]
    pub fn s2n_x509_trust_store_has_certs(store: *mut s2n_x509_trust_store) -> u8;
}
extern "C" {
    #[doc = " Initializes the trust store to default system paths"]
    pub fn s2n_x509_trust_store_from_system_defaults(
        store: *mut s2n_x509_trust_store,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Initialize trust store from a PEM. This will allocate memory, and load PEM into the Trust Store"]
    pub fn s2n_x509_trust_store_add_pem(
        store: *mut s2n_x509_trust_store,
        pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Initialize trust store from a CA file. This will allocate memory, and load each cert in the file into the trust store"]
    #[doc = "  Returns 0 on success, or S2N error codes on failure."]
    pub fn s2n_x509_trust_store_from_ca_file(
        store: *mut s2n_x509_trust_store,
        ca_pem_filename: *const ::libc::c_char,
        ca_dir: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Cleans up, and frees any underlying memory in the trust store."]
    pub fn s2n_x509_trust_store_wipe(store: *mut s2n_x509_trust_store);
}
extern "C" {
    #[doc = " Initialize the validator in unsafe mode. No validity checks for OCSP, host checks, or X.509 will be performed."]
    pub fn s2n_x509_validator_init_no_x509_validation(
        validator: *mut s2n_x509_validator,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Initialize the validator in safe mode. Will use trust store to validate x.509 certificates, ocsp responses, and will call"]
    #[doc = "  the verify host callback to determine if a subject name or alternative name from the cert should be trusted."]
    #[doc = "  Returns 0 on success, and an S2N_ERR_* on failure."]
    pub fn s2n_x509_validator_init(
        validator: *mut s2n_x509_validator,
        trust_store: *mut s2n_x509_trust_store,
        check_ocsp: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Sets the maximum depth for a cert chain that can be used at validation."]
    pub fn s2n_x509_validator_set_max_chain_depth(
        validator: *mut s2n_x509_validator,
        max_depth: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Cleans up underlying memory and data members. Struct can be reused afterwards."]
    pub fn s2n_x509_validator_wipe(validator: *mut s2n_x509_validator);
}
extern "C" {
    #[doc = " Validates a certificate chain against the configured trust store in safe mode. In unsafe mode, it will find the public key"]
    #[doc = " and return it but not validate the certificates. Alternative Names and Subject Name will be passed to the host verification callback."]
    #[doc = " The verification callback will be possibly called multiple times depending on how many names are found."]
    #[doc = " If any of those calls return TRUE, that stage of the validation will continue, otherwise once all names are tried and none matched as"]
    #[doc = " trusted, the chain will be considered UNTRUSTED."]
    #[doc = ""]
    #[doc = " This function can only be called once per instance of an s2n_x509_validator. If must be called prior to calling"]
    #[doc = " s2n_x509_validator_validate_cert_stapled_ocsp_response()."]
    pub fn s2n_x509_validator_validate_cert_chain(
        validator: *mut s2n_x509_validator,
        conn: *mut s2n_connection,
        cert_chain_in: *mut u8,
        cert_chain_len: u32,
        pkey_type: *mut s2n_pkey_type::Type,
        public_key_out: *mut s2n_pkey,
    ) -> s2n_cert_validation_code::Type;
}
extern "C" {
    #[doc = " Validates an ocsp response against the most recent certificate chain. Also verifies the timestamps on the response. This function can only be"]
    #[doc = " called once per instance of an s2n_x509_validator and only after a successful call to s2n_x509_validator_validate_cert_chain()."]
    pub fn s2n_x509_validator_validate_cert_stapled_ocsp_response(
        validator: *mut s2n_x509_validator,
        conn: *mut s2n_connection,
        ocsp_response: *const u8,
        size: u32,
    ) -> s2n_cert_validation_code::Type;
}
extern "C" {
    #[must_use]
    #[doc = " Validates that each certificate in a peer's cert chain contains only signature algorithms in a security policy's"]
    #[doc = " certificate_signatures_preference list."]
    pub fn s2n_validate_certificate_signature(
        conn: *mut s2n_connection,
        x509_cert: *mut X509,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_validate_sig_scheme_supported(
        conn: *mut s2n_connection,
        x509_cert: *mut X509,
        cert_sig_preferences: *const s2n_signature_preferences,
    ) -> s2n_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_set {
    pub data: *mut s2n_array,
    pub comparator: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::libc::c_void,
            arg2: *const ::libc::c_void,
        ) -> ::libc::c_int,
    >,
}
extern "C" {
    #[must_use]
    pub fn s2n_set_validate(set: *const s2n_set) -> s2n_result;
}
extern "C" {
    pub fn s2n_set_new(
        element_size: u32,
        comparator: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::libc::c_void,
                arg2: *const ::libc::c_void,
            ) -> ::libc::c_int,
        >,
    ) -> *mut s2n_set;
}
extern "C" {
    #[must_use]
    pub fn s2n_set_add(set: *mut s2n_set, element: *mut ::libc::c_void) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_set_get(
        set: *mut s2n_set,
        idx: u32,
        element: *mut *mut ::libc::c_void,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_set_remove(set: *mut s2n_set, idx: u32) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_set_free_p(pset: *mut *mut s2n_set) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_set_free(set: *mut s2n_set) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_set_len(set: *mut s2n_set, len: *mut u32) -> s2n_result;
}
#[repr(C)]
pub struct s2n_config {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub dhparams: *mut s2n_dh_params,
    pub domain_name_to_cert_map: *mut s2n_map,
    pub default_certs_by_type: certs_by_type,
    pub application_protocols: s2n_blob,
    pub status_request_type: s2n_status_request_type::Type,
    pub wall_clock: s2n_clock_time_nanoseconds,
    pub monotonic_clock: s2n_clock_time_nanoseconds,
    pub security_policy: *const s2n_security_policy,
    pub sys_clock_ctx: *mut ::libc::c_void,
    pub monotonic_clock_ctx: *mut ::libc::c_void,
    pub client_hello_cb: s2n_client_hello_fn,
    pub client_hello_cb_mode: s2n_client_hello_cb_mode::Type,
    pub client_hello_cb_ctx: *mut ::libc::c_void,
    pub session_state_lifetime_in_nanos: u64,
    pub ticket_keys: *mut s2n_set,
    pub ticket_key_hashes: *mut s2n_set,
    pub encrypt_decrypt_key_lifetime_in_nanos: u64,
    pub decrypt_key_lifetime_in_nanos: u64,
    pub cache_store: s2n_cache_store_callback,
    pub cache_store_data: *mut ::libc::c_void,
    pub cache_retrieve: s2n_cache_retrieve_callback,
    pub cache_retrieve_data: *mut ::libc::c_void,
    pub cache_delete: s2n_cache_delete_callback,
    pub cache_delete_data: *mut ::libc::c_void,
    pub ct_type: s2n_ct_support_level::Type,
    pub client_cert_auth_type: s2n_cert_auth_type::Type,
    pub alert_behavior: s2n_alert_behavior::Type,
    pub verify_host: ::core::option::Option<
        unsafe extern "C" fn(
            host_name: *const ::libc::c_char,
            host_name_len: usize,
            data: *mut ::libc::c_void,
        ) -> u8,
    >,
    pub data_for_verify_host: *mut ::libc::c_void,
    pub cert_tiebreak_cb: s2n_cert_tiebreak_callback,
    pub mfl_code: u8,
    pub initial_tickets_to_send: u8,
    pub trust_store: s2n_x509_trust_store,
    pub max_verify_cert_chain_depth: u16,
    pub async_pkey_cb: s2n_async_pkey_fn,
    pub psk_selection_cb: s2n_psk_selection_callback,
    pub psk_selection_ctx: *mut ::libc::c_void,
    pub key_log_cb: s2n_key_log_fn,
    pub key_log_ctx: *mut ::libc::c_void,
    pub session_ticket_cb: s2n_session_ticket_fn,
    pub session_ticket_ctx: *mut ::libc::c_void,
    pub early_data_cb: s2n_early_data_cb,
    pub server_max_early_data_size: u32,
    pub psk_mode: s2n_psk_mode::Type,
}
impl s2n_config {
    #[inline]
    pub fn cert_allocated(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cert_allocated(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn default_certs_are_explicit(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_default_certs_are_explicit(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_tickets(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_tickets(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_session_cache(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_session_cache(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accept_mfl(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_accept_mfl(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn check_ocsp(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_check_ocsp(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_x509_validation(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_x509_validation(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn max_verify_cert_chain_depth_set(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_max_verify_cert_chain_depth_set(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn quic_enabled(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_quic_enabled(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cert_req_dss_legacy_compat_enabled(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cert_req_dss_legacy_compat_enabled(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cert_allocated: ::libc::c_uint,
        default_certs_are_explicit: ::libc::c_uint,
        use_tickets: ::libc::c_uint,
        use_session_cache: ::libc::c_uint,
        accept_mfl: ::libc::c_uint,
        check_ocsp: ::libc::c_uint,
        disable_x509_validation: ::libc::c_uint,
        max_verify_cert_chain_depth_set: ::libc::c_uint,
        quic_enabled: ::libc::c_uint,
        cert_req_dss_legacy_compat_enabled: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cert_allocated: u32 = unsafe { ::core::mem::transmute(cert_allocated) };
            cert_allocated as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let default_certs_are_explicit: u32 =
                unsafe { ::core::mem::transmute(default_certs_are_explicit) };
            default_certs_are_explicit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let use_tickets: u32 = unsafe { ::core::mem::transmute(use_tickets) };
            use_tickets as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let use_session_cache: u32 = unsafe { ::core::mem::transmute(use_session_cache) };
            use_session_cache as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let accept_mfl: u32 = unsafe { ::core::mem::transmute(accept_mfl) };
            accept_mfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let check_ocsp: u32 = unsafe { ::core::mem::transmute(check_ocsp) };
            check_ocsp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disable_x509_validation: u32 =
                unsafe { ::core::mem::transmute(disable_x509_validation) };
            disable_x509_validation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let max_verify_cert_chain_depth_set: u32 =
                unsafe { ::core::mem::transmute(max_verify_cert_chain_depth_set) };
            max_verify_cert_chain_depth_set as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let quic_enabled: u32 = unsafe { ::core::mem::transmute(quic_enabled) };
            quic_enabled as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let cert_req_dss_legacy_compat_enabled: u32 =
                unsafe { ::core::mem::transmute(cert_req_dss_legacy_compat_enabled) };
            cert_req_dss_legacy_compat_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn s2n_config_defaults_init() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_fetch_default_config() -> *mut s2n_config;
}
extern "C" {
    pub fn s2n_config_set_unsafe_for_testing(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_init_session_ticket_keys(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_free_session_ticket_keys(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_wipe_static_configs();
}
extern "C" {
    pub fn s2n_config_get_single_default_cert(
        config: *mut s2n_config,
    ) -> *mut s2n_cert_chain_and_key;
}
extern "C" {
    pub fn s2n_config_get_num_default_certs(config: *mut s2n_config) -> ::libc::c_int;
}
pub type kem_extension_size = u16;
pub type kem_public_key_size = u16;
pub type kem_private_key_size = u16;
pub type kem_shared_secret_size = u16;
pub type kem_ciphertext_key_size = u16;
#[repr(C)]
pub struct s2n_kem {
    pub name: *const ::libc::c_char,
    pub kem_extension_id: kem_extension_size,
    pub public_key_length: kem_public_key_size,
    pub private_key_length: kem_private_key_size,
    pub shared_secret_key_length: kem_shared_secret_size,
    pub ciphertext_length: kem_ciphertext_key_size,
    pub generate_keypair: ::core::option::Option<
        unsafe extern "C" fn(
            public_key: *mut ::libc::c_uchar,
            private_key: *mut ::libc::c_uchar,
        ) -> ::libc::c_int,
    >,
    pub encapsulate: ::core::option::Option<
        unsafe extern "C" fn(
            ciphertext: *mut ::libc::c_uchar,
            shared_secret: *mut ::libc::c_uchar,
            public_key: *const ::libc::c_uchar,
        ) -> ::libc::c_int,
    >,
    pub decapsulate: ::core::option::Option<
        unsafe extern "C" fn(
            shared_secret: *mut ::libc::c_uchar,
            ciphertext: *const ::libc::c_uchar,
            private_key: *const ::libc::c_uchar,
        ) -> ::libc::c_int,
    >,
}
#[repr(C)]
pub struct s2n_kem_params {
    pub kem: *const s2n_kem,
    pub public_key: s2n_blob,
    pub private_key: s2n_blob,
    pub shared_secret: s2n_blob,
}
#[repr(C)]
pub struct s2n_iana_to_kem {
    pub iana_value: [u8; 2usize],
    pub kems: *mut *const s2n_kem,
    pub kem_count: u8,
}
#[repr(C)]
pub struct s2n_kem_group {
    pub name: *const ::libc::c_char,
    pub iana_id: u16,
    pub client_share_size: u16,
    pub server_share_size: u16,
    pub curve: *const s2n_ecc_named_curve,
    pub kem: *const s2n_kem,
}
#[repr(C)]
pub struct s2n_kem_group_params {
    pub kem_group: *const s2n_kem_group,
    pub kem_params: s2n_kem_params,
    pub ecc_params: s2n_ecc_evp_params,
}
extern "C" {
    pub static s2n_bike1_l1_r1: s2n_kem;
}
extern "C" {
    pub static s2n_bike1_l1_r2: s2n_kem;
}
extern "C" {
    pub static s2n_bike_l1_r3: s2n_kem;
}
extern "C" {
    pub static s2n_sike_p503_r1: s2n_kem;
}
extern "C" {
    pub static s2n_sike_p434_r2: s2n_kem;
}
extern "C" {
    pub static s2n_kyber_512_r2: s2n_kem;
}
extern "C" {
    pub static s2n_kyber_512_90s_r2: s2n_kem;
}
extern "C" {
    pub static s2n_kyber_512_r3: s2n_kem;
}
extern "C" {
    pub static s2n_sike_p434_r3: s2n_kem;
}
extern "C" {
    pub static s2n_secp256r1_sike_p434_r2: s2n_kem_group;
}
extern "C" {
    pub static s2n_secp256r1_bike1_l1_r2: s2n_kem_group;
}
extern "C" {
    pub static s2n_secp256r1_kyber_512_r2: s2n_kem_group;
}
extern "C" {
    pub static s2n_x25519_sike_p434_r2: s2n_kem_group;
}
extern "C" {
    pub static s2n_x25519_bike1_l1_r2: s2n_kem_group;
}
extern "C" {
    pub static s2n_x25519_kyber_512_r2: s2n_kem_group;
}
extern "C" {
    #[must_use]
    pub fn s2n_kem_generate_keypair(kem_params: *mut s2n_kem_params) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_kem_encapsulate(
        kem_params: *mut s2n_kem_params,
        ciphertext: *mut s2n_blob,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_kem_decapsulate(
        kem_params: *mut s2n_kem_params,
        ciphertext: *const s2n_blob,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_choose_kem_with_peer_pref_list(
        iana_value: *const u8,
        client_kem_ids: *mut s2n_blob,
        server_kem_pref_list: *mut *const s2n_kem,
        num_server_supported_kems: u8,
        chosen_kem: *mut *const s2n_kem,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_choose_kem_without_peer_pref_list(
        iana_value: *const u8,
        server_kem_pref_list: *mut *const s2n_kem,
        num_server_supported_kems: u8,
        chosen_kem: *mut *const s2n_kem,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_free(kem_params: *mut s2n_kem_params) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_group_free(kem_group_params: *mut s2n_kem_group_params) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cipher_suite_to_kem(
        iana_value: *const u8,
        supported_params: *mut *const s2n_iana_to_kem,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_get_kem_from_extension_id(
        kem_id: kem_extension_size,
        kem: *mut *const s2n_kem,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_send_public_key(
        out: *mut s2n_stuffer,
        kem_params: *mut s2n_kem_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_recv_public_key(
        in_: *mut s2n_stuffer,
        kem_params: *mut s2n_kem_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_send_ciphertext(
        out: *mut s2n_stuffer,
        kem_params: *mut s2n_kem_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_recv_ciphertext(
        in_: *mut s2n_stuffer,
        kem_params: *mut s2n_kem_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kyber_512_r3_crypto_kem_keypair(
        pk: *mut ::libc::c_uchar,
        sk: *mut ::libc::c_uchar,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kyber_512_r3_crypto_kem_enc(
        ct: *mut ::libc::c_uchar,
        ss: *mut ::libc::c_uchar,
        pk: *const ::libc::c_uchar,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kyber_512_r3_crypto_kem_dec(
        ss: *mut ::libc::c_uchar,
        ct: *const ::libc::c_uchar,
        sk: *const ::libc::c_uchar,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_sike_p434_r3_crypto_kem_keypair(
        pk: *mut ::libc::c_uchar,
        sk: *mut ::libc::c_uchar,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_sike_p434_r3_crypto_kem_enc(
        ct: *mut ::libc::c_uchar,
        ss: *mut ::libc::c_uchar,
        pk: *const ::libc::c_uchar,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_sike_p434_r3_crypto_kem_dec(
        ss: *mut ::libc::c_uchar,
        ct: *const ::libc::c_uchar,
        sk: *const ::libc::c_uchar,
    ) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_crypto_parameters {
    pub server_public_key: s2n_pkey,
    pub client_public_key: s2n_pkey,
    pub server_dh_params: s2n_dh_params,
    pub server_ecc_evp_params: s2n_ecc_evp_params,
    pub mutually_supported_curves: [*const s2n_ecc_named_curve; 4usize],
    pub client_ecc_evp_params: [s2n_ecc_evp_params; 4usize],
    pub server_kem_group_params: s2n_kem_group_params,
    pub chosen_client_kem_group_params: *mut s2n_kem_group_params,
    pub client_kem_group_params: [s2n_kem_group_params; 6usize],
    pub mutually_supported_kem_groups: [*const s2n_kem_group; 6usize],
    pub kem_params: s2n_kem_params,
    pub client_key_exchange_message: s2n_blob,
    pub client_pq_kem_extension: s2n_blob,
    pub conn_sig_scheme: s2n_signature_scheme,
    pub client_cert_chain: s2n_blob,
    pub client_cert_pkey_type: s2n_pkey_type::Type,
    pub client_cert_sig_scheme: s2n_signature_scheme,
    pub cipher_suite: *mut s2n_cipher_suite,
    pub client_key: s2n_session_key,
    pub server_key: s2n_session_key,
    pub rsa_premaster_secret: [u8; 48usize],
    pub master_secret: [u8; 48usize],
    pub client_random: [u8; 32usize],
    pub server_random: [u8; 32usize],
    pub client_implicit_iv: [u8; 16usize],
    pub server_implicit_iv: [u8; 16usize],
    pub client_app_secret: [u8; 48usize],
    pub server_app_secret: [u8; 48usize],
    pub signature_hash: s2n_hash_state,
    pub client_record_mac: s2n_hmac_state,
    pub server_record_mac: s2n_hmac_state,
    pub record_mac_copy_workspace: s2n_hmac_state,
    pub client_sequence_number: [u8; 8usize],
    pub server_sequence_number: [u8; 8usize],
}
pub mod s2n_handshake_type_flag {
    pub type Type = ::libc::c_uint;
    pub const INITIAL: Type = 0;
    pub const NEGOTIATED: Type = 1;
    pub const FULL_HANDSHAKE: Type = 2;
    pub const CLIENT_AUTH: Type = 4;
    pub const NO_CLIENT_CERT: Type = 8;
}
extern "C" {
    #[must_use]
    pub fn s2n_handshake_type_set_flag(
        conn: *mut s2n_connection,
        flag: s2n_handshake_type_flag::Type,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_handshake_type_check_flag(
        conn: *mut s2n_connection,
        flag: s2n_handshake_type_flag::Type,
    ) -> bool;
}
pub mod s2n_tls12_handshake_type_flag {
    pub type Type = ::libc::c_uint;
    pub const TLS12_PERFECT_FORWARD_SECRECY: Type = 16;
    pub const OCSP_STATUS: Type = 32;
    pub const WITH_SESSION_TICKET: Type = 64;
}
extern "C" {
    #[must_use]
    pub fn s2n_handshake_type_set_tls12_flag(
        conn: *mut s2n_connection,
        flag: s2n_tls12_handshake_type_flag::Type,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_handshake_type_unset_tls12_flag(
        conn: *mut s2n_connection,
        flag: s2n_tls12_handshake_type_flag::Type,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_handshake_type_check_tls12_flag(
        conn: *mut s2n_connection,
        flag: s2n_tls12_handshake_type_flag::Type,
    ) -> bool;
}
pub mod s2n_tls13_handshake_type_flag {
    pub type Type = ::libc::c_uint;
    pub const HELLO_RETRY_REQUEST: Type = 16;
    pub const MIDDLEBOX_COMPAT: Type = 32;
    pub const WITH_EARLY_DATA: Type = 64;
    pub const EARLY_CLIENT_CCS: Type = 128;
}
extern "C" {
    #[must_use]
    pub fn s2n_handshake_type_set_tls13_flag(
        conn: *mut s2n_connection,
        flag: s2n_tls13_handshake_type_flag::Type,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_handshake_type_check_tls13_flag(
        conn: *mut s2n_connection,
        flag: s2n_tls13_handshake_type_flag::Type,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn s2n_handshake_type_reset(conn: *mut s2n_connection) -> s2n_result;
}
#[repr(C)]
pub struct s2n_sig_scheme_list {
    pub iana_list: [u16; 64usize],
    pub len: u8,
}
extern "C" {
    pub fn s2n_choose_default_sig_scheme(
        conn: *mut s2n_connection,
        sig_scheme_out: *mut s2n_signature_scheme,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_choose_sig_scheme_from_peer_preference_list(
        conn: *mut s2n_connection,
        sig_hash_algs: *mut s2n_sig_scheme_list,
        sig_scheme_out: *mut s2n_signature_scheme,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_get_and_validate_negotiated_signature_scheme(
        conn: *mut s2n_connection,
        in_: *mut s2n_stuffer,
        chosen_sig_scheme: *mut s2n_signature_scheme,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_supported_sig_scheme_list(
        in_: *mut s2n_stuffer,
        sig_hash_algs: *mut s2n_sig_scheme_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_send_supported_sig_scheme_list(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_supported_sig_schemes_count(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_supported_sig_scheme_list_size(conn: *mut s2n_connection) -> ::libc::c_int;
}
pub mod message_type_t {
    pub type Type = ::libc::c_uint;
    pub const CLIENT_HELLO: Type = 0;
    pub const SERVER_HELLO: Type = 1;
    pub const SERVER_CERT: Type = 2;
    pub const SERVER_NEW_SESSION_TICKET: Type = 3;
    pub const SERVER_CERT_STATUS: Type = 4;
    pub const SERVER_KEY: Type = 5;
    pub const SERVER_CERT_REQ: Type = 6;
    pub const SERVER_HELLO_DONE: Type = 7;
    pub const CLIENT_CERT: Type = 8;
    pub const CLIENT_KEY: Type = 9;
    pub const CLIENT_CERT_VERIFY: Type = 10;
    pub const CLIENT_CHANGE_CIPHER_SPEC: Type = 11;
    pub const CLIENT_FINISHED: Type = 12;
    pub const SERVER_CHANGE_CIPHER_SPEC: Type = 13;
    pub const SERVER_FINISHED: Type = 14;
    pub const ENCRYPTED_EXTENSIONS: Type = 15;
    pub const SERVER_CERT_VERIFY: Type = 16;
    pub const HELLO_RETRY_MSG: Type = 17;
    pub const END_OF_EARLY_DATA: Type = 18;
    pub const APPLICATION_DATA: Type = 19;
}
pub mod s2n_async_state {
    pub type Type = ::libc::c_uint;
    pub const S2N_ASYNC_NOT_INVOKED: Type = 0;
    pub const S2N_ASYNC_INVOKING_CALLBACK: Type = 1;
    pub const S2N_ASYNC_INVOKED_WAITING: Type = 2;
    pub const S2N_ASYNC_INVOKED_COMPLETE: Type = 3;
}
#[repr(C)]
pub struct s2n_handshake_parameters {
    pub client_sig_hash_algs: s2n_sig_scheme_list,
    pub server_sig_hash_algs: s2n_sig_scheme_list,
    pub our_chain_and_key: *mut s2n_cert_chain_and_key,
    pub exact_sni_matches: [*mut s2n_cert_chain_and_key; 3usize],
    pub wc_sni_matches: [*mut s2n_cert_chain_and_key; 3usize],
    pub exact_sni_match_exists: u8,
    pub wc_sni_match_exists: u8,
}
#[repr(C)]
pub struct s2n_handshake {
    pub io: s2n_stuffer,
    pub md5: s2n_hash_state,
    pub sha1: s2n_hash_state,
    pub sha224: s2n_hash_state,
    pub sha256: s2n_hash_state,
    pub sha384: s2n_hash_state,
    pub sha512: s2n_hash_state,
    pub md5_sha1: s2n_hash_state,
    pub ccv_hash_copy: s2n_hash_state,
    pub prf_md5_hash_copy: s2n_hash_state,
    pub prf_sha1_hash_copy: s2n_hash_state,
    pub prf_tls12_hash_copy: s2n_hash_state,
    pub server_hello_copy: s2n_hash_state,
    pub server_finished_copy: s2n_hash_state,
    pub required_hash_algs: [u8; 8usize],
    pub server_finished: [u8; 48usize],
    pub client_finished: [u8; 48usize],
    pub handshake_type: u32,
    pub message_number: ::libc::c_int,
    pub end_of_messages: message_type_t::Type,
    pub async_state: s2n_async_state::Type,
    pub early_data_async_state: s2n_offered_early_data,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl s2n_handshake {
    #[inline]
    pub fn client_hello_received(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_client_hello_received(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn paused(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_paused(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsa_failed(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rsa_failed(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        client_hello_received: ::libc::c_uint,
        paused: ::libc::c_uint,
        rsa_failed: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let client_hello_received: u32 =
                unsafe { ::core::mem::transmute(client_hello_received) };
            client_hello_received as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let paused: u32 = unsafe { ::core::mem::transmute(paused) };
            paused as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rsa_failed: u32 = unsafe { ::core::mem::transmute(rsa_failed) };
            rsa_failed as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn s2n_conn_get_current_message_type(conn: *mut s2n_connection) -> message_type_t::Type;
}
extern "C" {
    pub fn s2n_conn_set_handshake_type(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_conn_set_handshake_no_client_cert(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_handshake_require_all_hashes(handshake: *mut s2n_handshake) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_handshake_is_hash_required(
        handshake: *mut s2n_handshake,
        hash_alg: s2n_hash_algorithm::Type,
    ) -> u8;
}
extern "C" {
    pub fn s2n_conn_update_required_handshake_hashes(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_handshake_get_hash_state(
        conn: *mut s2n_connection,
        hash_alg: s2n_hash_algorithm::Type,
        hash_state: *mut s2n_hash_state,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_handshake_reset_hash_state(
        conn: *mut s2n_connection,
        hash_alg: s2n_hash_algorithm::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_conn_find_name_matching_certs(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_create_wildcard_hostname(
        hostname: *mut s2n_stuffer,
        output: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_get_compatible_cert_chain_and_key(
        conn: *mut s2n_connection,
        cert_type: s2n_pkey_type::Type,
    ) -> *mut s2n_cert_chain_and_key;
}
extern "C" {
    pub fn s2n_conn_update_handshake_hashes(
        conn: *mut s2n_connection,
        data: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_quic_read_handshake_message(
        conn: *mut s2n_connection,
        message_type: *mut u8,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_quic_write_handshake_message(
        conn: *mut s2n_connection,
        in_: *mut s2n_blob,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_negotiate_until_message(
        conn: *mut s2n_connection,
        blocked: *mut s2n_blocked_status::Type,
        end_message: message_type_t::Type,
    ) -> s2n_result;
}
#[repr(C)]
pub struct p_hash_state {
    pub s2n_hmac: s2n_hmac_state,
    pub evp_hmac: s2n_evp_hmac_state,
}
#[repr(C)]
pub struct s2n_prf_working_space {
    pub tls: s2n_prf_working_space__bindgen_ty_1,
    pub ssl3: s2n_prf_working_space__bindgen_ty_2,
}
#[repr(C)]
pub struct s2n_prf_working_space__bindgen_ty_1 {
    pub p_hash_hmac_impl: *const s2n_p_hash_hmac,
    pub p_hash: p_hash_state,
    pub digest0: [u8; 64usize],
    pub digest1: [u8; 64usize],
}
#[repr(C)]
pub struct s2n_prf_working_space__bindgen_ty_2 {
    pub md5: s2n_hash_state,
    pub sha1: s2n_hash_state,
    pub md5_digest: [u8; 16usize],
    pub sha1_digest: [u8; 20usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_p_hash_hmac {
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(ws: *mut s2n_prf_working_space) -> ::libc::c_int,
    >,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            ws: *mut s2n_prf_working_space,
            alg: s2n_hmac_algorithm::Type,
            secret: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            ws: *mut s2n_prf_working_space,
            data: *const ::libc::c_void,
            size: u32,
        ) -> ::libc::c_int,
    >,
    pub final_: ::core::option::Option<
        unsafe extern "C" fn(
            ws: *mut s2n_prf_working_space,
            digest: *mut ::libc::c_void,
            size: u32,
        ) -> ::libc::c_int,
    >,
    pub reset: ::core::option::Option<
        unsafe extern "C" fn(ws: *mut s2n_prf_working_space) -> ::libc::c_int,
    >,
    pub cleanup: ::core::option::Option<
        unsafe extern "C" fn(ws: *mut s2n_prf_working_space) -> ::libc::c_int,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(ws: *mut s2n_prf_working_space) -> ::libc::c_int,
    >,
}
extern "C" {
    pub fn s2n_prf_new(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_prf_free(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls_prf_master_secret(
        conn: *mut s2n_connection,
        premaster_secret: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hybrid_prf_master_secret(
        conn: *mut s2n_connection,
        premaster_secret: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_prf_key_expansion(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_prf_server_finished(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_prf_client_finished(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_enable_quic(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_quic_transport_parameters(
        conn: *mut s2n_connection,
        data_buffer: *const u8,
        data_len: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_quic_transport_parameters(
        conn: *mut s2n_connection,
        data_buffer: *mut *const u8,
        data_len: *mut u16,
    ) -> ::libc::c_int;
}
pub mod s2n_secret_type_t {
    pub type Type = ::libc::c_uint;
    pub const S2N_CLIENT_EARLY_TRAFFIC_SECRET: Type = 0;
    pub const S2N_CLIENT_HANDSHAKE_TRAFFIC_SECRET: Type = 1;
    pub const S2N_SERVER_HANDSHAKE_TRAFFIC_SECRET: Type = 2;
    pub const S2N_CLIENT_APPLICATION_TRAFFIC_SECRET: Type = 3;
    pub const S2N_SERVER_APPLICATION_TRAFFIC_SECRET: Type = 4;
}
pub type s2n_secret_cb = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut ::libc::c_void,
        conn: *mut s2n_connection,
        secret_type: s2n_secret_type_t::Type,
        secret: *mut u8,
        secret_size: u8,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_connection_set_secret_callback(
        conn: *mut s2n_connection,
        cb_func: s2n_secret_cb,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
pub mod keyupdate_status {
    pub type Type = ::libc::c_uint;
    pub const SENDING: Type = 0;
    pub const RECEIVING: Type = 1;
}
extern "C" {
    pub fn s2n_key_update_recv(
        conn: *mut s2n_connection,
        request: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_key_update_send(
        conn: *mut s2n_connection,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_kex {
    pub is_ephemeral: bool,
    pub hybrid: [*const s2n_kex; 2usize],
    pub connection_supported: ::core::option::Option<
        unsafe extern "C" fn(
            cipher_suite: *const s2n_cipher_suite,
            conn: *mut s2n_connection,
            is_supported: *mut bool,
        ) -> s2n_result,
    >,
    pub configure_connection: ::core::option::Option<
        unsafe extern "C" fn(
            cipher_suite: *const s2n_cipher_suite,
            conn: *mut s2n_connection,
        ) -> s2n_result,
    >,
    pub server_key_recv_read_data: ::core::option::Option<
        unsafe extern "C" fn(
            conn: *mut s2n_connection,
            data_to_verify: *mut s2n_blob,
            kex_data: *mut s2n_kex_raw_server_data,
        ) -> ::libc::c_int,
    >,
    pub server_key_recv_parse_data: ::core::option::Option<
        unsafe extern "C" fn(
            conn: *mut s2n_connection,
            kex_data: *mut s2n_kex_raw_server_data,
        ) -> ::libc::c_int,
    >,
    pub server_key_send: ::core::option::Option<
        unsafe extern "C" fn(
            conn: *mut s2n_connection,
            data_to_sign: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
    pub client_key_recv: ::core::option::Option<
        unsafe extern "C" fn(conn: *mut s2n_connection, shared_key: *mut s2n_blob) -> ::libc::c_int,
    >,
    pub client_key_send: ::core::option::Option<
        unsafe extern "C" fn(conn: *mut s2n_connection, shared_key: *mut s2n_blob) -> ::libc::c_int,
    >,
    pub prf: ::core::option::Option<
        unsafe extern "C" fn(
            conn: *mut s2n_connection,
            premaster_secret: *mut s2n_blob,
        ) -> ::libc::c_int,
    >,
}
extern "C" {
    pub static s2n_kem: s2n_kex;
}
extern "C" {
    pub static s2n_rsa: s2n_kex;
}
extern "C" {
    pub static s2n_dhe: s2n_kex;
}
extern "C" {
    pub static s2n_ecdhe: s2n_kex;
}
extern "C" {
    pub static s2n_hybrid_ecdhe_kem: s2n_kex;
}
extern "C" {
    #[must_use]
    pub fn s2n_kex_supported(
        cipher_suite: *const s2n_cipher_suite,
        conn: *mut s2n_connection,
        is_supported: *mut bool,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_configure_kex(
        cipher_suite: *const s2n_cipher_suite,
        conn: *mut s2n_connection,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_kex_is_ephemeral(kex: *const s2n_kex, is_ephemeral: *mut bool) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_kex_server_key_recv_read_data(
        kex: *const s2n_kex,
        conn: *mut s2n_connection,
        data_to_verify: *mut s2n_blob,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_kex_server_key_recv_parse_data(
        kex: *const s2n_kex,
        conn: *mut s2n_connection,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_kex_server_key_send(
        kex: *const s2n_kex,
        conn: *mut s2n_connection,
        data_to_sign: *mut s2n_blob,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_kex_client_key_recv(
        kex: *const s2n_kex,
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_kex_client_key_send(
        kex: *const s2n_kex,
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_kex_tls_prf(
        kex: *const s2n_kex,
        conn: *mut s2n_connection,
        premaster_secret: *mut s2n_blob,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_kex_includes(kex: *const s2n_kex, query: *const s2n_kex) -> bool;
}
#[repr(C)]
pub struct s2n_kem_preferences {
    pub kem_count: u8,
    pub kems: *mut *const s2n_kem,
    pub tls13_kem_group_count: u8,
    pub tls13_kem_groups: *mut *const s2n_kem_group,
}
extern "C" {
    pub fn s2n_kem_preferences_includes_tls13_kem_group(
        kem_preferences: *const s2n_kem_preferences,
        query_iana_id: u16,
    ) -> bool;
}
#[repr(C)]
pub struct s2n_ecc_preferences {
    pub count: u8,
    pub ecc_curves: *const *const s2n_ecc_named_curve,
}
extern "C" {
    pub static s2n_ecc_preferences_20140601: s2n_ecc_preferences;
}
extern "C" {
    pub static s2n_ecc_preferences_20200310: s2n_ecc_preferences;
}
extern "C" {
    pub static s2n_ecc_preferences_20201021: s2n_ecc_preferences;
}
extern "C" {
    pub static s2n_ecc_preferences_test_all: s2n_ecc_preferences;
}
extern "C" {
    pub static s2n_ecc_preferences_null: s2n_ecc_preferences;
}
extern "C" {
    pub fn s2n_check_ecc_preferences_curves_list(
        ecc_preferences: *const s2n_ecc_preferences,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_preferences_includes_curve(
        ecc_preferences: *const s2n_ecc_preferences,
        query_iana_id: u16,
    ) -> bool;
}
pub mod s2n_authentication_method {
    pub type Type = ::libc::c_uint;
    pub const S2N_AUTHENTICATION_RSA: Type = 0;
    pub const S2N_AUTHENTICATION_ECDSA: Type = 1;
    pub const S2N_AUTHENTICATION_METHOD_SENTINEL: Type = 2;
}
#[repr(C)]
pub struct s2n_record_algorithm {
    pub cipher: *const s2n_cipher,
    pub hmac_alg: s2n_hmac_algorithm::Type,
    pub flags: u32,
    pub encryption_limit: u64,
}
extern "C" {
    pub static s2n_record_alg_null: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_rc4_md5: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_rc4_sha: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_3des_sha: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes128_sha: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes128_sha_composite: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes128_sha256: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes128_sha256_composite: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes256_sha: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes256_sha_composite: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes256_sha256: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes256_sha256_composite: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes256_sha384: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes128_gcm: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_aes256_gcm: s2n_record_algorithm;
}
extern "C" {
    pub static s2n_record_alg_chacha20_poly1305: s2n_record_algorithm;
}
#[repr(C)]
pub struct s2n_cipher_suite {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub name: *const ::libc::c_char,
    pub iana_value: [u8; 2usize],
    pub key_exchange_alg: *const s2n_kex,
    pub auth_method: s2n_authentication_method::Type,
    pub record_alg: *const s2n_record_algorithm,
    pub all_record_algs: [*const s2n_record_algorithm; 2usize],
    pub num_record_algs: u8,
    pub sslv3_record_alg: *const s2n_record_algorithm,
    pub sslv3_cipher_suite: *mut s2n_cipher_suite,
    pub prf_alg: s2n_hmac_algorithm::Type,
    pub minimum_required_tls_version: u8,
}
impl s2n_cipher_suite {
    #[inline]
    pub fn available(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_available(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(available: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let available: u32 = unsafe { ::core::mem::transmute(available) };
            available as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut s2n_null_cipher_suite: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_rsa_with_rc4_128_md5: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_rsa_with_rc4_128_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_rsa_with_3des_ede_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_dhe_rsa_with_3des_ede_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_rsa_with_aes_128_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_dhe_rsa_with_aes_128_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_rsa_with_aes_256_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_dhe_rsa_with_aes_256_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_rsa_with_aes_128_cbc_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_rsa_with_aes_256_cbc_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_dhe_rsa_with_aes_128_cbc_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_dhe_rsa_with_aes_256_cbc_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_rsa_with_aes_128_gcm_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_rsa_with_aes_256_gcm_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_dhe_rsa_with_aes_128_gcm_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_dhe_rsa_with_aes_256_gcm_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_ecdsa_with_aes_128_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_ecdsa_with_aes_256_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_rsa_with_3des_ede_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_rsa_with_aes_128_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_rsa_with_aes_256_cbc_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_ecdsa_with_aes_128_cbc_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_ecdsa_with_aes_256_cbc_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_rsa_with_aes_128_cbc_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_rsa_with_aes_256_cbc_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_ecdsa_with_aes_128_gcm_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_ecdsa_with_aes_256_gcm_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_rsa_with_aes_128_gcm_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_rsa_with_aes_256_gcm_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_rsa_with_chacha20_poly1305_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_dhe_rsa_with_chacha20_poly1305_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_ecdsa_with_chacha20_poly1305_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_rsa_with_rc4_128_sha: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_kyber_rsa_with_aes_256_gcm_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_bike_rsa_with_aes_256_gcm_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_ecdhe_sike_rsa_with_aes_256_gcm_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_tls13_aes_256_gcm_sha384: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_tls13_aes_128_gcm_sha256: s2n_cipher_suite;
}
extern "C" {
    pub static mut s2n_tls13_chacha20_poly1305_sha256: s2n_cipher_suite;
}
extern "C" {
    pub fn s2n_cipher_suites_init() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cipher_suites_cleanup() -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_cipher_suite_from_iana(
        iana: *const u8,
        cipher_suite: *mut *mut s2n_cipher_suite,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_set_cipher_as_client(conn: *mut s2n_connection, wire: *mut u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_set_cipher_as_sslv2_server(
        conn: *mut s2n_connection,
        wire: *mut u8,
        count: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_set_cipher_as_tls_server(
        conn: *mut s2n_connection,
        wire: *mut u8,
        count: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_enable_tls13() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_use_default_tls13_config() -> bool;
}
extern "C" {
    pub fn s2n_disable_tls13() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_reset_tls13() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_is_valid_tls13_cipher(version: *const u8) -> bool;
}
extern "C" {
    pub fn s2n_is_middlebox_compat_enabled(conn: *mut s2n_connection) -> bool;
}
extern "C" {
    pub fn s2n_is_hello_retry_handshake(conn: *mut s2n_connection) -> bool;
}
extern "C" {
    pub fn s2n_is_hello_retry_message(conn: *mut s2n_connection) -> bool;
}
extern "C" {
    pub fn s2n_set_hello_retry_required(conn: *mut s2n_connection) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_cipher_preferences {
    pub count: u8,
    pub suites: *mut *mut s2n_cipher_suite,
}
#[repr(C)]
pub struct s2n_security_policy {
    pub minimum_protocol_version: u8,
    pub cipher_preferences: *const s2n_cipher_preferences,
    pub kem_preferences: *const s2n_kem_preferences,
    pub signature_preferences: *const s2n_signature_preferences,
    pub certificate_signature_preferences: *const s2n_signature_preferences,
    pub ecc_preferences: *const s2n_ecc_preferences,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_security_policy_selection {
    pub version: *const ::libc::c_char,
    pub security_policy: *const s2n_security_policy,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl s2n_security_policy_selection {
    #[inline]
    pub fn ecc_extension_required(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ecc_extension_required(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pq_kem_extension_required(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pq_kem_extension_required(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn supports_tls13(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_supports_tls13(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ecc_extension_required: ::libc::c_uint,
        pq_kem_extension_required: ::libc::c_uint,
        supports_tls13: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ecc_extension_required: u32 =
                unsafe { ::core::mem::transmute(ecc_extension_required) };
            ecc_extension_required as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pq_kem_extension_required: u32 =
                unsafe { ::core::mem::transmute(pq_kem_extension_required) };
            pq_kem_extension_required as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let supports_tls13: u32 = unsafe { ::core::mem::transmute(supports_tls13) };
            supports_tls13 as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn s2n_security_policies_init() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecc_is_extension_required(security_policy: *const s2n_security_policy) -> bool;
}
extern "C" {
    pub fn s2n_pq_kem_is_extension_required(security_policy: *const s2n_security_policy) -> bool;
}
extern "C" {
    pub fn s2n_security_policy_supports_tls13(security_policy: *const s2n_security_policy) -> bool;
}
extern "C" {
    pub fn s2n_find_security_policy_from_version(
        version: *const ::libc::c_char,
        security_policy: *mut *const s2n_security_policy,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_validate_kem_preferences(
        kem_preferences: *const s2n_kem_preferences,
        pq_kem_extension_required: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_validate_certificate_signature_preferences(
        s2n_certificate_signature_preferences: *const s2n_signature_preferences,
    ) -> s2n_result;
}
#[repr(C)]
pub struct s2n_timer {
    pub time: u64,
}
extern "C" {
    #[must_use]
    pub fn s2n_timer_start(config: *mut s2n_config, timer: *mut s2n_timer) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_timer_elapsed(
        config: *mut s2n_config,
        timer: *mut s2n_timer,
        nanoseconds: *mut u64,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_timer_reset(
        config: *mut s2n_config,
        timer: *mut s2n_timer,
        nanoseconds: *mut u64,
    ) -> s2n_result;
}
pub mod s2n_session_ticket_status {
    pub type Type = ::libc::c_uint;
    pub const S2N_NO_TICKET: Type = 0;
    pub const S2N_DECRYPT_TICKET: Type = 1;
    pub const S2N_NEW_TICKET: Type = 2;
}
#[repr(C)]
pub struct s2n_connection {
    pub config: *mut s2n_config,
    pub security_policy_override: *const s2n_security_policy,
    pub context: *mut ::libc::c_void,
    pub secret_cb: s2n_secret_cb,
    pub secret_cb_context: *mut ::libc::c_void,
    pub send: s2n_send_fn,
    pub recv: s2n_recv_fn,
    pub send_io_context: *mut ::libc::c_void,
    pub recv_io_context: *mut ::libc::c_void,
    pub managed_io: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub extension_requests_sent: s2n_extension_bitfield,
    pub extension_requests_received: s2n_extension_bitfield,
    pub mode: s2n_mode::Type,
    pub blinding: s2n_blinding::Type,
    pub write_timer: s2n_timer,
    pub last_write_elapsed: u64,
    pub delay: u64,
    pub session_id: [u8; 32usize],
    pub session_id_len: u8,
    pub client_hello_version: u8,
    pub client_protocol_version: u8,
    pub server_protocol_version: u8,
    pub actual_protocol_version: u8,
    pub actual_protocol_version_established: u8,
    pub initial: s2n_crypto_parameters,
    pub secure: s2n_crypto_parameters,
    pub client: *mut s2n_crypto_parameters,
    pub server: *mut s2n_crypto_parameters,
    pub handshake_params: s2n_handshake_parameters,
    pub psk_params: s2n_psk_parameters,
    pub prf_space: s2n_prf_working_space,
    pub client_cert_auth_type_overridden: u8,
    pub client_cert_auth_type: s2n_cert_auth_type::Type,
    pub header_in_data: [u8; 5usize],
    pub header_in: s2n_stuffer,
    pub in_: s2n_stuffer,
    pub out: s2n_stuffer,
    pub in_status: s2n_connection__bindgen_ty_1::Type,
    pub current_user_data_consumed: isize,
    pub alert_in_data: [u8; 2usize],
    pub alert_in: s2n_stuffer,
    pub reader_alert_out_data: [u8; 2usize],
    pub writer_alert_out_data: [u8; 2usize],
    pub reader_alert_out: s2n_stuffer,
    pub writer_alert_out: s2n_stuffer,
    pub handshake: s2n_handshake,
    pub max_outgoing_fragment_length: u16,
    pub dynamic_record_resize_threshold: u32,
    pub dynamic_record_timeout_threshold: u16,
    pub active_application_bytes_consumed: u64,
    pub mfl_code: u8,
    pub wire_bytes_in: u64,
    pub wire_bytes_out: u64,
    pub early_data_bytes: u64,
    pub closing: sig_atomic_t,
    pub closed: sig_atomic_t,
    pub server_name: [::libc::c_char; 256usize],
    pub application_protocol: [::libc::c_char; 256usize],
    pub status_type: s2n_status_request_type::Type,
    pub status_response: s2n_blob,
    pub ct_level_requested: s2n_ct_support_level::Type,
    pub ct_response: s2n_blob,
    pub our_quic_transport_parameters: s2n_blob,
    pub peer_quic_transport_parameters: s2n_blob,
    pub client_hello: s2n_client_hello,
    pub x509_validator: s2n_x509_validator,
    pub verify_host_fn: s2n_verify_host_fn,
    pub data_for_verify_host: *mut ::libc::c_void,
    pub verify_host_fn_overridden: u8,
    pub session_ticket_status: s2n_session_ticket_status::Type,
    pub client_ticket: s2n_blob,
    pub ticket_lifetime_hint: u32,
    pub tls13_ticket_fields: s2n_ticket_fields,
    pub ticket_ext_data: [u8; 104usize],
    pub client_ticket_to_decrypt: s2n_stuffer,
    pub resumption_master_secret: [u8; 48usize],
    pub application_protocols_overridden: s2n_blob,
    pub cookie_stuffer: s2n_stuffer,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub preferred_key_shares: u8,
    pub send_in_use: bool,
    pub recv_in_use: bool,
    pub tickets_to_send: u16,
    pub tickets_sent: u16,
    pub early_data_state: s2n_early_data_state::Type,
    pub server_max_early_data_size: u32,
    pub server_early_data_context: s2n_blob,
    pub server_keying_material_lifetime: u32,
}
pub mod s2n_connection__bindgen_ty_1 {
    pub type Type = ::libc::c_uint;
    pub const ENCRYPTED: Type = 0;
    pub const PLAINTEXT: Type = 1;
}
impl s2n_connection {
    #[inline]
    pub fn corked_io(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_corked_io(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn client_session_resumed(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_client_session_resumed(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_notify_queued(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_notify_queued(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secure_renegotiation(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secure_renegotiation(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ec_point_formats(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ec_point_formats(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ipv6(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ipv6(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn server_name_used(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_server_name_used(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_fd_broken(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write_fd_broken(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        corked_io: ::libc::c_uint,
        client_session_resumed: ::libc::c_uint,
        close_notify_queued: ::libc::c_uint,
        secure_renegotiation: ::libc::c_uint,
        ec_point_formats: ::libc::c_uint,
        ipv6: ::libc::c_uint,
        server_name_used: ::libc::c_uint,
        write_fd_broken: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let corked_io: u32 = unsafe { ::core::mem::transmute(corked_io) };
            corked_io as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let client_session_resumed: u32 =
                unsafe { ::core::mem::transmute(client_session_resumed) };
            client_session_resumed as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_notify_queued: u32 = unsafe { ::core::mem::transmute(close_notify_queued) };
            close_notify_queued as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let secure_renegotiation: u32 = unsafe { ::core::mem::transmute(secure_renegotiation) };
            secure_renegotiation as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ec_point_formats: u32 = unsafe { ::core::mem::transmute(ec_point_formats) };
            ec_point_formats as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ipv6: u32 = unsafe { ::core::mem::transmute(ipv6) };
            ipv6 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let server_name_used: u32 = unsafe { ::core::mem::transmute(server_name_used) };
            server_name_used as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let write_fd_broken: u32 = unsafe { ::core::mem::transmute(write_fd_broken) };
            write_fd_broken as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn key_update_pending(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_key_update_pending(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn early_data_expected(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_early_data_expected(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn server_max_early_data_size_overridden(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_server_max_early_data_size_overridden(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psk_mode_overridden(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_psk_mode_overridden(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_notify_received(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_notify_received(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        key_update_pending: ::libc::c_uint,
        early_data_expected: ::libc::c_uint,
        server_max_early_data_size_overridden: ::libc::c_uint,
        psk_mode_overridden: ::libc::c_uint,
        close_notify_received: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let key_update_pending: u32 = unsafe { ::core::mem::transmute(key_update_pending) };
            key_update_pending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let early_data_expected: u32 = unsafe { ::core::mem::transmute(early_data_expected) };
            early_data_expected as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let server_max_early_data_size_overridden: u32 =
                unsafe { ::core::mem::transmute(server_max_early_data_size_overridden) };
            server_max_early_data_size_overridden as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let psk_mode_overridden: u32 = unsafe { ::core::mem::transmute(psk_mode_overridden) };
            psk_mode_overridden as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let close_notify_received: u32 =
                unsafe { ::core::mem::transmute(close_notify_received) };
            close_notify_received as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn s2n_connection_is_managed_corked(s2n_connection: *const s2n_connection)
        -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_is_client_auth_enabled(
        s2n_connection: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_kill(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_send_stuffer(
        stuffer: *mut s2n_stuffer,
        conn: *mut s2n_connection,
        len: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_recv_stuffer(
        stuffer: *mut s2n_stuffer,
        conn: *mut s2n_connection,
        len: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_connection_wipe_all_keyshares(conn: *mut s2n_connection) -> s2n_result;
}
extern "C" {
    pub fn s2n_connection_get_cipher_preferences(
        conn: *mut s2n_connection,
        cipher_preferences: *mut *const s2n_cipher_preferences,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_security_policy(
        conn: *mut s2n_connection,
        security_policy: *mut *const s2n_security_policy,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_kem_preferences(
        conn: *mut s2n_connection,
        kem_preferences: *mut *const s2n_kem_preferences,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_signature_preferences(
        conn: *mut s2n_connection,
        signature_preferences: *mut *const s2n_signature_preferences,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_ecc_preferences(
        conn: *mut s2n_connection,
        ecc_preferences: *mut *const s2n_ecc_preferences,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_protocol_preferences(
        conn: *mut s2n_connection,
        protocol_preferences: *mut *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_protocol_version(conn: *const s2n_connection) -> u8;
}
extern "C" {
    pub fn s2n_connection_set_keyshare_by_name_for_testing(
        conn: *mut s2n_connection,
        curve_name: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_hex(
        stuffer: *mut s2n_stuffer,
        out: *mut s2n_stuffer,
        n: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_uint8_hex(stuffer: *mut s2n_stuffer, u: *mut u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_uint16_hex(stuffer: *mut s2n_stuffer, u: *mut u16) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_uint32_hex(stuffer: *mut s2n_stuffer, u: *mut u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_read_uint64_hex(stuffer: *mut s2n_stuffer, u: *mut u64) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_hex(
        stuffer: *mut s2n_stuffer,
        in_: *mut s2n_stuffer,
        n: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_uint8_hex(stuffer: *mut s2n_stuffer, u: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_uint16_hex(stuffer: *mut s2n_stuffer, u: u16) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_uint32_hex(stuffer: *mut s2n_stuffer, u: u32) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_write_uint64_hex(stuffer: *mut s2n_stuffer, u: u64) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_stuffer_alloc_ro_from_hex_string(
        stuffer: *mut s2n_stuffer,
        str_: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_print_connection(conn: *mut s2n_connection, marker: *const ::libc::c_char);
}
extern "C" {
    pub fn s2n_connection_set_io_stuffers(
        input: *mut s2n_stuffer,
        output: *mut s2n_stuffer,
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_test_io_pair {
    pub client: ::libc::c_int,
    pub server: ::libc::c_int,
}
extern "C" {
    pub fn s2n_io_pair_init(io_pair: *mut s2n_test_io_pair) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_io_pair_init_non_blocking(io_pair: *mut s2n_test_io_pair) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_io_pair_close(io_pair: *mut s2n_test_io_pair) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_io_pair_close_one_end(
        io_pair: *mut s2n_test_io_pair,
        mode_to_close: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_io_pair_shutdown_one_end(
        io_pair: *mut s2n_test_io_pair,
        mode_to_close: ::libc::c_int,
        how: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_io_pair(
        conn: *mut s2n_connection,
        io_pair: *mut s2n_test_io_pair,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connections_set_io_pair(
        client: *mut s2n_connection,
        server: *mut s2n_connection,
        io_pair: *mut s2n_test_io_pair,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_fd_set_blocking(fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_fd_set_non_blocking(fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_set_connection_hello_retry_flags(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_allow_all_response_extensions(conn: *mut s2n_connection)
        -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_all_protocol_versions(
        conn: *mut s2n_connection,
        version: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_config_mock_wall_clock(
        config: *mut s2n_config,
        test_time_in_ns: *mut u64,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_test_psk_new(conn: *mut s2n_connection) -> *mut s2n_psk;
}
extern "C" {
    #[must_use]
    pub fn s2n_append_test_psk_with_early_data(
        conn: *mut s2n_connection,
        max_early_data: u32,
        cipher_suite: *const s2n_cipher_suite,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_append_test_chosen_psk_with_early_data(
        conn: *mut s2n_connection,
        max_early_data: u32,
        cipher_suite: *const s2n_cipher_suite,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_read_test_pem(
        pem_path: *const ::libc::c_char,
        pem_out: *mut ::libc::c_char,
        max_size: ::libc::c_long,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_test_cert_chain_and_key_new(
        chain_and_key: *mut *mut s2n_cert_chain_and_key,
        cert_chain_file: *const ::libc::c_char,
        private_key_file: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_negotiate_test_server_and_client(
        server_conn: *mut s2n_connection,
        client_conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_negotiate_test_server_and_client_until_message(
        server_conn: *mut s2n_connection,
        client_conn: *mut s2n_connection,
        message_type: message_type_t::Type,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_shutdown_test_server_and_client(
        server_conn: *mut s2n_connection,
        client_conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_negotiate_test_server_and_client_with_early_data(
        server_conn: *mut s2n_connection,
        client_conn: *mut s2n_connection,
        early_data_to_send: *mut s2n_blob,
        early_data_received: *mut s2n_blob,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_test_kem_with_kat(
        kem: *const s2n_kem,
        kat_file: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_test_hybrid_ecdhe_kem_with_kat(
        kem: *const s2n_kem,
        cipher_suite: *mut s2n_cipher_suite,
        cipher_pref_version: *const ::libc::c_char,
        kat_file_name: *const ::libc::c_char,
        server_key_message_length: u32,
        client_key_message_length: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_pq_noop_asm() -> s2n_result;
}
extern "C" {
    pub fn s2n_pq_no_asm_available() -> bool;
}
extern "C" {
    pub fn s2n_public_ecc_keys_are_equal(
        params_1: *mut s2n_ecc_evp_params,
        params_2: *mut s2n_ecc_evp_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_recv_public_key_fuzz_test(
        buf: *const u8,
        len: usize,
        kem_params: *mut s2n_kem_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_recv_ciphertext_fuzz_test(
        buf: *const u8,
        len: usize,
        kem_params: *mut s2n_kem_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_recv_ciphertext_fuzz_test_init(
        kat_file_path: *const ::libc::c_char,
        kem_params: *mut s2n_kem_params,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_drbg_test(argc: ::libc::c_int, argv: *mut *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_alpn_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_alpn_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_client_alpn(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_key_share_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_key_share_recv(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_client_key_share_size(conn: *mut s2n_connection) -> u32;
}
extern "C" {
    pub fn s2n_extensions_client_key_share_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_max_frag_len_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_max_frag_len_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_client_max_frag_len(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_pq_kem_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_pq_kem_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
        pq_kem_list_size: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_pq_kem_extension(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_psk_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_client_psk_should_send(conn: *mut s2n_connection) -> bool;
}
extern "C" {
    pub static s2n_client_renegotiation_info_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_recv_client_renegotiation_info(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_sct_list_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_sct_list_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_client_sct_list(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_server_name_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_server_name_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_parse_client_hello_server_name(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_session_ticket_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_session_ticket_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_client_session_ticket_ext(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_signature_algorithms_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_signature_algorithms_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_client_signature_algorithms_recv(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_client_signature_algorithms_size(
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_status_request_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_status_request_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_client_status_request(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_supported_groups_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extension_should_send_if_ecc_enabled(conn: *mut s2n_connection) -> bool;
}
extern "C" {
    pub fn s2n_extensions_client_supported_groups_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_client_supported_groups(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_supported_versions_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_client_supported_versions_recv(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_client_supported_versions_size(
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_client_supported_versions_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_cookie_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_server_cookie_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_cookie_size(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_cookie_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_cookie_recv(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_client_early_data_indication_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_server_early_data_indication_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_nst_early_data_indication_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_client_ec_point_format_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_server_ec_point_format_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_server_ecc_point_format_extension_size(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_client_ec_point_formats(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
#[repr(C)]
pub struct s2n_extension_type_list {
    pub extension_types: *const *const s2n_extension_type,
    pub count: u8,
}
extern "C" {
    pub fn s2n_extension_type_list_get(
        list_type: s2n_extension_list_id::Type,
        extension_type_list: *mut *mut s2n_extension_type_list,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecdhe_parameters_send(
        ecc_evp_params: *mut s2n_ecc_evp_params,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_psk_key_exchange_modes_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_quic_transport_parameters_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_server_alpn_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_tls13_server_status_request_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_server_certificate_status_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_certificate_status_recv(
        conn: *mut s2n_connection,
        in_: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_server_key_share_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_server_key_share_select(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_server_key_share_send_size(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_server_key_share_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_server_key_share_recv(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_server_max_fragment_length_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_server_psk_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_server_renegotiation_info_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_recv_server_renegotiation_info_ext(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_send_server_renegotiation_info_ext(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_renegotiation_info_ext_size(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_server_sct_list_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_server_server_name_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_server_session_ticket_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_recv_server_session_ticket_ext(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_send_server_session_ticket_ext(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_session_ticket_ext_size(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_server_signature_algorithms_extension: s2n_extension_type;
}
extern "C" {
    pub static s2n_server_status_request_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_server_extensions_status_request_send_size(
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_extensions_status_request_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_server_status_request(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_server_supported_versions_extension: s2n_extension_type;
}
extern "C" {
    pub fn s2n_extensions_server_supported_versions_recv(
        conn: *mut s2n_connection,
        extension: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_server_supported_versions_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_extensions_server_supported_versions_size(
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_minimum_supported_version(
        conn: *mut s2n_connection,
        min_version: *mut u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_process_alert_fragment(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_queue_writer_close_alert_warning(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_queue_reader_unsupported_protocol_version_alert(
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_queue_reader_handshake_failure_alert(conn: *mut s2n_connection) -> ::libc::c_int;
}
pub type s2n_async_pkey_sign_complete = ::core::option::Option<
    unsafe extern "C" fn(conn: *mut s2n_connection, signature: *mut s2n_blob) -> ::libc::c_int,
>;
pub type s2n_async_pkey_decrypt_complete = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        rsa_failed: bool,
        decrypted: *mut s2n_blob,
    ) -> ::libc::c_int,
>;
extern "C" {
    #[must_use]
    pub fn s2n_async_pkey_decrypt(
        conn: *mut s2n_connection,
        encrypted: *mut s2n_blob,
        init_decrypted: *mut s2n_blob,
        on_complete: s2n_async_pkey_decrypt_complete,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_async_pkey_sign(
        conn: *mut s2n_connection,
        sig_alg: s2n_signature_algorithm::Type,
        digest: *mut s2n_hash_state,
        on_complete: s2n_async_pkey_sign_complete,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_is_cipher_suite_valid_for_auth(
        conn: *mut s2n_connection,
        cipher_suite: *mut s2n_cipher_suite,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_is_sig_scheme_valid_for_auth(
        conn: *mut s2n_connection,
        sig_scheme: *const s2n_signature_scheme,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_is_cert_type_valid_for_auth(
        conn: *mut s2n_connection,
        cert_type: s2n_pkey_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_select_certs_for_server_auth(
        conn: *mut s2n_connection,
        chosen_certs: *mut *mut s2n_cert_chain_and_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dhe_client_key_send(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecdhe_client_key_send(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_rsa_client_key_send(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_client_key_send(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hybrid_client_key_send(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dhe_client_key_recv(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecdhe_client_key_recv(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_rsa_client_key_recv(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_client_key_recv(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hybrid_client_key_recv(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dhe_client_key_external(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecdhe_client_key_external(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_rsa_client_key_external(
        conn: *mut s2n_connection,
        shared_key: *mut s2n_blob,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_connection_prf_handles {
    pub p_hash_s2n_hmac: s2n_hmac_evp_backup,
    pub p_hash_evp_hmac: s2n_evp_hmac_state,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_connection_hash_handles {
    pub md5: s2n_hash_evp_digest,
    pub sha1: s2n_hash_evp_digest,
    pub sha224: s2n_hash_evp_digest,
    pub sha256: s2n_hash_evp_digest,
    pub sha384: s2n_hash_evp_digest,
    pub sha512: s2n_hash_evp_digest,
    pub md5_sha1: s2n_hash_evp_digest,
    pub ccv_hash_copy: s2n_hash_evp_digest,
    pub prf_md5_hash_copy: s2n_hash_evp_digest,
    pub prf_sha1_hash_copy: s2n_hash_evp_digest,
    pub prf_tls12_hash_copy: s2n_hash_evp_digest,
    pub server_hello_copy: s2n_hash_evp_digest,
    pub server_finished_copy: s2n_hash_evp_digest,
    pub prf_md5: s2n_hash_evp_digest,
    pub prf_sha1: s2n_hash_evp_digest,
    pub initial_signature_hash: s2n_hash_evp_digest,
    pub secure_signature_hash: s2n_hash_evp_digest,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_connection_hmac_handles {
    pub initial_client: s2n_hmac_evp_backup,
    pub initial_client_copy: s2n_hmac_evp_backup,
    pub initial_server: s2n_hmac_evp_backup,
    pub secure_client: s2n_hmac_evp_backup,
    pub secure_client_copy: s2n_hmac_evp_backup,
    pub secure_server: s2n_hmac_evp_backup,
}
extern "C" {
    pub fn s2n_connection_save_prf_state(
        prf_handles: *mut s2n_connection_prf_handles,
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_save_hash_state(
        hash_handles: *mut s2n_connection_hash_handles,
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_save_hmac_state(
        hmac_handles: *mut s2n_connection_hmac_handles,
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_restore_prf_state(
        conn: *mut s2n_connection,
        prf_handles: *mut s2n_connection_prf_handles,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_restore_hash_state(
        conn: *mut s2n_connection,
        hash_handles: *mut s2n_connection_hash_handles,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_restore_hmac_state(
        conn: *mut s2n_connection,
        hmac_handles: *mut s2n_connection_hmac_handles,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_key_log_hex_encode(
        output: *mut s2n_stuffer,
        bytes: *mut u8,
        len: usize,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_key_log_tls12_secret(conn: *mut s2n_connection) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_key_log_tls13_secret(
        conn: *mut s2n_connection,
        secret: *mut s2n_blob,
        secret_type: s2n_secret_type_t::Type,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_post_handshake_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_post_handshake_send(
        conn: *mut s2n_connection,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_protocol_preferences_read(
        protocol_preferences: *mut s2n_stuffer,
        protocol: *mut s2n_blob,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_protocol_preferences_contain(
        protocol_preferences: *mut s2n_blob,
        protocol: *mut s2n_blob,
        contains: *mut bool,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_record_max_write_payload_size(
        conn: *mut s2n_connection,
        max_fragment_size: *mut u16,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_record_min_write_payload_size(
        conn: *mut s2n_connection,
        payload_size: *mut u16,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_record_write(
        conn: *mut s2n_connection,
        content_type: u8,
        in_: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_record_writev(
        conn: *mut s2n_connection,
        content_type: u8,
        in_: *const iovec,
        in_count: ::libc::c_int,
        offs: usize,
        to_write: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_record_parse(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_record_header_parse(
        conn: *mut s2n_connection,
        content_type: *mut u8,
        fragment_length: *mut u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_parse_record_type(
        stuffer: *mut s2n_stuffer,
        record_type: *mut u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_sslv2_record_header_parse(
        conn: *mut s2n_connection,
        record_type: *mut u8,
        client_protocol_version: *mut u8,
        fragment_length: *mut u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_verify_cbc(
        conn: *mut s2n_connection,
        hmac: *mut s2n_hmac_state,
        decrypted: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_aead_aad_init(
        conn: *const s2n_connection,
        sequence_number: *mut u8,
        content_type: u8,
        record_length: u16,
        ad: *mut s2n_stuffer,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_tls13_aead_aad_init(
        record_length: u16,
        tag_length: u8,
        ad: *mut s2n_stuffer,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_record_parse_aead(
        cipher_suite: *const s2n_cipher_suite,
        conn: *mut s2n_connection,
        content_type: u8,
        encrypted_length: u16,
        implicit_iv: *mut u8,
        mac: *mut s2n_hmac_state,
        sequence_number: *mut u8,
        session_key: *mut s2n_session_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_record_parse_cbc(
        cipher_suite: *const s2n_cipher_suite,
        conn: *mut s2n_connection,
        content_type: u8,
        encrypted_length: u16,
        implicit_iv: *mut u8,
        mac: *mut s2n_hmac_state,
        sequence_number: *mut u8,
        session_key: *mut s2n_session_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_record_parse_composite(
        cipher_suite: *const s2n_cipher_suite,
        conn: *mut s2n_connection,
        content_type: u8,
        encrypted_length: u16,
        implicit_iv: *mut u8,
        mac: *mut s2n_hmac_state,
        sequence_number: *mut u8,
        session_key: *mut s2n_session_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_record_parse_stream(
        cipher_suite: *const s2n_cipher_suite,
        conn: *mut s2n_connection,
        content_type: u8,
        encrypted_length: u16,
        implicit_iv: *mut u8,
        mac: *mut s2n_hmac_state,
        sequence_number: *mut u8,
        session_key: *mut s2n_session_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_extensions_send(
        conn: *mut s2n_connection,
        out: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_extensions_recv(
        conn: *mut s2n_connection,
        in_: *mut s2n_stuffer,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dhe_server_key_recv_read_data(
        conn: *mut s2n_connection,
        data_to_verify: *mut s2n_blob,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecdhe_server_key_recv_read_data(
        conn: *mut s2n_connection,
        data_to_verify: *mut s2n_blob,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_server_key_recv_read_data(
        conn: *mut s2n_connection,
        data_to_verify: *mut s2n_blob,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hybrid_server_key_recv_read_data(
        conn: *mut s2n_connection,
        total_data_to_verify: *mut s2n_blob,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dhe_server_key_recv_parse_data(
        conn: *mut s2n_connection,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecdhe_server_key_recv_parse_data(
        conn: *mut s2n_connection,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_server_key_recv_parse_data(
        conn: *mut s2n_connection,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hybrid_server_key_recv_parse_data(
        conn: *mut s2n_connection,
        raw_server_data: *mut s2n_kex_raw_server_data,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_dhe_server_key_send(
        conn: *mut s2n_connection,
        data_to_sign: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_ecdhe_server_key_send(
        conn: *mut s2n_connection,
        data_to_sign: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_kem_server_key_send(
        conn: *mut s2n_connection,
        data_to_sign: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_hybrid_server_key_send(
        conn: *mut s2n_connection,
        data_to_sign: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub static mut s2n_unknown_protocol_version: u8;
}
extern "C" {
    pub static mut s2n_highest_protocol_version: u8;
}
extern "C" {
    pub fn s2n_flush(
        conn: *mut s2n_connection,
        more: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_hello_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_hello_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_establish_session(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_sslv2_client_hello_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_hello_retry_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_hello_retry_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_hello_write_message(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_hello_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_hello_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_encrypted_extensions_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_encrypted_extensions_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_cert_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_cert_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_status_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_status_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_key_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_key_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_req_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_req_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_cert_req_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_cert_req_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_done_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_done_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_cert_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_cert_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_key_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_key_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_cert_verify_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_cert_verify_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_cert_verify_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_cert_verify_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_nst_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_nst_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    #[must_use]
    pub fn s2n_tls13_server_nst_send(
        conn: *mut s2n_connection,
        blocked: *mut s2n_blocked_status::Type,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_tls13_server_nst_write(
        conn: *mut s2n_connection,
        output: *mut s2n_stuffer,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_tls13_server_nst_recv(
        conn: *mut s2n_connection,
        input: *mut s2n_stuffer,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_ccs_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_basic_ccs_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_ccs_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_ccs_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_finished_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_finished_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_finished_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_finished_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_client_finished_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_client_finished_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_server_finished_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_server_finished_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_end_of_early_data_send(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_end_of_early_data_recv(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_process_client_hello(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_handshake_write_header(out: *mut s2n_stuffer, message_type: u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_handshake_finish_header(out: *mut s2n_stuffer) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_handshake_parse_header(
        conn: *mut s2n_connection,
        message_type: *mut u8,
        length: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_read_full_record(
        conn: *mut s2n_connection,
        record_type: *mut u8,
        isSSLv2: *mut ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_recv_close_notify(
        conn: *mut s2n_connection,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_mac_verify(
        keys: *mut s2n_tls13_keys,
        finished_verify: *mut s2n_blob,
        wire_verify: *mut s2n_blob,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_keys_from_conn(
        keys: *mut s2n_tls13_keys,
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_tls13_handle_secrets(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_update_application_traffic_keys(
        conn: *mut s2n_connection,
        mode: s2n_mode::Type,
        status: keyupdate_status::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_server_hello_retry_recreate_transcript(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub static s2n_hash_tls_to_alg: [s2n_hash_algorithm::Type; 7usize];
}
extern "C" {
    pub static s2n_hash_alg_to_tls: [u8; 7usize];
}
extern "C" {
    #[must_use]
    #[doc = " Converts an asn1 formatted time string to ticks since epoch in nanoseconds."]
    #[doc = " ticks is an output parameter. Returns 0 on success and -1 on failure."]
    pub fn s2n_asn1_time_to_nano_since_epoch_ticks(
        asn1_time: *const ::libc::c_char,
        len: u32,
        ticks: *mut u64,
    ) -> s2n_result;
}
extern "C" {
    pub fn s2n_map_new() -> *mut s2n_map;
}
extern "C" {
    pub fn s2n_map_new_with_initial_capacity(capacity: u32) -> *mut s2n_map;
}
extern "C" {
    #[must_use]
    pub fn s2n_map_add(map: *mut s2n_map, key: *mut s2n_blob, value: *mut s2n_blob) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_map_put(map: *mut s2n_map, key: *mut s2n_blob, value: *mut s2n_blob) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_map_complete(map: *mut s2n_map) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_map_unlock(map: *mut s2n_map) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_map_lookup(
        map: *const s2n_map,
        key: *mut s2n_blob,
        value: *mut s2n_blob,
        key_found: *mut bool,
    ) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_map_free(map: *mut s2n_map) -> s2n_result;
}
#[repr(C)]
pub struct s2n_map_entry {
    pub key: s2n_blob,
    pub value: s2n_blob,
}
#[repr(C)]
pub struct s2n_map {
    pub capacity: u32,
    pub size: u32,
    pub immutable: ::libc::c_int,
    pub table: *mut s2n_map_entry,
}
extern "C" {
    #[must_use]
    pub fn s2n_rand_init() -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_rand_cleanup() -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_get_seed_entropy(blob: *mut s2n_blob) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_get_mix_entropy(blob: *mut s2n_blob) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_rand_cleanup_thread() -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_set_private_drbg_for_test(drbg: s2n_drbg) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_get_public_random_data(blob: *mut s2n_blob) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_get_public_random_bytes_used(bytes_used: *mut u64) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_get_private_random_data(blob: *mut s2n_blob) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_get_private_random_bytes_used(bytes_used: *mut u64) -> s2n_result;
}
extern "C" {
    #[must_use]
    pub fn s2n_public_random(max: i64, output: *mut u64) -> s2n_result;
}
extern "C" {
    #[must_use]
    #[doc = " Converts a binary representation of an ip address into its canonical string"]
    #[doc = " representation. Returns 0 on success and -1 on failure."]
    pub fn s2n_inet_ntop(
        af: ::libc::c_int,
        addr: *const ::libc::c_void,
        dst: *mut s2n_blob,
    ) -> s2n_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_socket_read_io_context {
    pub fd: ::libc::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub original_rcvlowat_val: ::libc::c_int,
}
impl s2n_socket_read_io_context {
    #[inline]
    pub fn tcp_quickack_set(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcp_quickack_set(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn original_rcvlowat_is_set(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original_rcvlowat_is_set(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcp_quickack_set: ::libc::c_uint,
        original_rcvlowat_is_set: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tcp_quickack_set: u32 = unsafe { ::core::mem::transmute(tcp_quickack_set) };
            tcp_quickack_set as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let original_rcvlowat_is_set: u32 =
                unsafe { ::core::mem::transmute(original_rcvlowat_is_set) };
            original_rcvlowat_is_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_socket_write_io_context {
    pub fd: ::libc::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub original_cork_val: ::libc::c_int,
}
impl s2n_socket_write_io_context {
    #[inline]
    pub fn original_cork_is_set(&self) -> ::libc::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original_cork_is_set(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        original_cork_is_set: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original_cork_is_set: u32 = unsafe { ::core::mem::transmute(original_cork_is_set) };
            original_cork_is_set as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn s2n_socket_quickack(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_read_snapshot(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_write_snapshot(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_read_restore(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_write_restore(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_was_corked(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_write_cork(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_write_uncork(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_set_read_size(
        conn: *mut s2n_connection,
        size: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_read(
        io_context: *mut ::libc::c_void,
        buf: *mut u8,
        len: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_write(
        io_context: *mut ::libc::c_void,
        buf: *const u8,
        len: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_socket_is_ipv6(fd: ::libc::c_int, ipv6: *mut u8) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_strcpy(
        buf: *mut ::libc::c_char,
        last: *mut ::libc::c_char,
        str_: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
