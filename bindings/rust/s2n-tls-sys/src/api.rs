/* automatically generated by rust-bindgen 0.58.1 */


// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0


#![allow(unused_imports, non_camel_case_types, non_snake_case, non_upper_case_globals)]

use libc::{iovec, FILE};


extern "C" {
    #[doc = " Returns the address of the thread-local `s2n_errno` variable"]
    #[doc = ""]
    #[doc = " This function can be used instead of trying to resolve `s2n_errno` directly"]
    #[doc = " in runtimes where thread-local variables may not be easily accessible."]
    pub fn s2n_errno_location() -> *mut ::libc::c_int;
}
pub mod s2n_error_type {
    pub type Type = ::libc::c_uint;
    pub const S2N_ERR_T_OK: Type = 0;
    pub const S2N_ERR_T_IO: Type = 1;
    pub const S2N_ERR_T_CLOSED: Type = 2;
    pub const S2N_ERR_T_BLOCKED: Type = 3;
    pub const S2N_ERR_T_ALERT: Type = 4;
    pub const S2N_ERR_T_PROTO: Type = 5;
    pub const S2N_ERR_T_INTERNAL: Type = 6;
    pub const S2N_ERR_T_USAGE: Type = 7;
}
extern "C" {
    pub fn s2n_error_get_type(error: ::libc::c_int) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_connection {
    _unused: [u8; 0],
}
extern "C" {
    pub fn s2n_get_openssl_version() -> ::libc::c_ulong;
}
extern "C" {
    pub fn s2n_init() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cleanup() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_new() -> *mut s2n_config;
}
extern "C" {
    pub fn s2n_config_free(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_free_dhparams(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_free_cert_chain_and_key(config: *mut s2n_config) -> ::libc::c_int;
}
pub type s2n_clock_time_nanoseconds = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut ::libc::c_void, arg2: *mut u64) -> ::libc::c_int,
>;
pub type s2n_cache_retrieve_callback = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        arg1: *mut ::libc::c_void,
        key: *const ::libc::c_void,
        key_size: u64,
        value: *mut ::libc::c_void,
        value_size: *mut u64,
    ) -> ::libc::c_int,
>;
pub type s2n_cache_store_callback = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        arg1: *mut ::libc::c_void,
        ttl_in_seconds: u64,
        key: *const ::libc::c_void,
        key_size: u64,
        value: *const ::libc::c_void,
        value_size: u64,
    ) -> ::libc::c_int,
>;
pub type s2n_cache_delete_callback = ::core::option::Option<
    unsafe extern "C" fn(
        conn: *mut s2n_connection,
        arg1: *mut ::libc::c_void,
        key: *const ::libc::c_void,
        key_size: u64,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_config_set_wall_clock(
        config: *mut s2n_config,
        clock_fn: s2n_clock_time_nanoseconds,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_monotonic_clock(
        config: *mut s2n_config,
        clock_fn: s2n_clock_time_nanoseconds,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_strerror(error: ::libc::c_int, lang: *const ::libc::c_char)
        -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_strerror_debug(
        error: ::libc::c_int,
        lang: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_strerror_name(error: ::libc::c_int) -> *const ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_stacktrace {
    _unused: [u8; 0],
}
extern "C" {
    pub fn s2n_stack_traces_enabled() -> bool;
}
extern "C" {
    pub fn s2n_stack_traces_enabled_set(newval: bool) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_calculate_stacktrace() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_print_stacktrace(fptr: *mut FILE) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_free_stacktrace() -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_get_stacktrace(trace: *mut s2n_stacktrace) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cache_store_callback(
        config: *mut s2n_config,
        cache_store_callback: s2n_cache_store_callback,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cache_retrieve_callback(
        config: *mut s2n_config,
        cache_retrieve_callback: s2n_cache_retrieve_callback,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cache_delete_callback(
        config: *mut s2n_config,
        cache_delete_callback: s2n_cache_delete_callback,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
pub type s2n_mem_init_callback = ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
pub type s2n_mem_cleanup_callback = ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
pub type s2n_mem_malloc_callback = ::core::option::Option<
    unsafe extern "C" fn(
        ptr: *mut *mut ::libc::c_void,
        requested: u32,
        allocated: *mut u32,
    ) -> ::libc::c_int,
>;
pub type s2n_mem_free_callback = ::core::option::Option<
    unsafe extern "C" fn(ptr: *mut ::libc::c_void, size: u32) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_mem_set_callbacks(
        mem_init_callback: s2n_mem_init_callback,
        mem_cleanup_callback: s2n_mem_cleanup_callback,
        mem_malloc_callback: s2n_mem_malloc_callback,
        mem_free_callback: s2n_mem_free_callback,
    ) -> ::libc::c_int;
}
pub type s2n_rand_init_callback = ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
pub type s2n_rand_cleanup_callback =
    ::core::option::Option<unsafe extern "C" fn() -> ::libc::c_int>;
pub type s2n_rand_seed_callback = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::libc::c_void, size: u32) -> ::libc::c_int,
>;
pub type s2n_rand_mix_callback = ::core::option::Option<
    unsafe extern "C" fn(data: *mut ::libc::c_void, size: u32) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_rand_set_callbacks(
        rand_init_callback: s2n_rand_init_callback,
        rand_cleanup_callback: s2n_rand_cleanup_callback,
        rand_seed_callback: s2n_rand_seed_callback,
        rand_mix_callback: s2n_rand_mix_callback,
    ) -> ::libc::c_int;
}
pub mod s2n_tls_extension_type {
    pub type Type = ::libc::c_uint;
    pub const S2N_EXTENSION_SERVER_NAME: Type = 0;
    pub const S2N_EXTENSION_MAX_FRAG_LEN: Type = 1;
    pub const S2N_EXTENSION_OCSP_STAPLING: Type = 5;
    pub const S2N_EXTENSION_SUPPORTED_GROUPS: Type = 10;
    pub const S2N_EXTENSION_EC_POINT_FORMATS: Type = 11;
    pub const S2N_EXTENSION_SIGNATURE_ALGORITHMS: Type = 13;
    pub const S2N_EXTENSION_ALPN: Type = 16;
    pub const S2N_EXTENSION_CERTIFICATE_TRANSPARENCY: Type = 18;
    pub const S2N_EXTENSION_RENEGOTIATION_INFO: Type = 65281;
}
pub mod s2n_max_frag_len {
    pub type Type = ::libc::c_uint;
    pub const S2N_TLS_MAX_FRAG_LEN_512: Type = 1;
    pub const S2N_TLS_MAX_FRAG_LEN_1024: Type = 2;
    pub const S2N_TLS_MAX_FRAG_LEN_2048: Type = 3;
    pub const S2N_TLS_MAX_FRAG_LEN_4096: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_cert {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_cert_chain_and_key {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_pkey {
    _unused: [u8; 0],
}
pub type s2n_cert_public_key = s2n_pkey;
pub type s2n_cert_private_key = s2n_pkey;
extern "C" {
    pub fn s2n_cert_chain_and_key_new() -> *mut s2n_cert_chain_and_key;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_load_pem(
        chain_and_key: *mut s2n_cert_chain_and_key,
        chain_pem: *const ::libc::c_char,
        private_key_pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_free(cert_and_key: *mut s2n_cert_chain_and_key) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_set_ctx(
        cert_and_key: *mut s2n_cert_chain_and_key,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_get_ctx(
        cert_and_key: *mut s2n_cert_chain_and_key,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn s2n_cert_chain_and_key_get_private_key(
        cert_and_key: *mut s2n_cert_chain_and_key,
    ) -> *mut s2n_cert_private_key;
}
pub type s2n_cert_tiebreak_callback = ::core::option::Option<
    unsafe extern "C" fn(
        cert1: *mut s2n_cert_chain_and_key,
        cert2: *mut s2n_cert_chain_and_key,
        name: *mut u8,
        name_len: u32,
    ) -> *mut s2n_cert_chain_and_key,
>;
extern "C" {
    pub fn s2n_config_set_cert_tiebreak_callback(
        config: *mut s2n_config,
        cert_tiebreak_cb: s2n_cert_tiebreak_callback,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_cert_chain_and_key(
        config: *mut s2n_config,
        cert_chain_pem: *const ::libc::c_char,
        private_key_pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_cert_chain_and_key_to_store(
        config: *mut s2n_config,
        cert_key_pair: *mut s2n_cert_chain_and_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cert_chain_and_key_defaults(
        config: *mut s2n_config,
        cert_key_pairs: *mut *mut s2n_cert_chain_and_key,
        num_cert_key_pairs: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_verification_ca_location(
        config: *mut s2n_config,
        ca_pem_filename: *const ::libc::c_char,
        ca_dir: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_pem_to_trust_store(
        config: *mut s2n_config,
        pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
pub type s2n_verify_host_fn = ::core::option::Option<
    unsafe extern "C" fn(
        host_name: *const ::libc::c_char,
        host_name_len: usize,
        data: *mut ::libc::c_void,
    ) -> u8,
>;
extern "C" {
    pub fn s2n_config_set_verify_host_callback(
        config: *mut s2n_config,
        arg1: s2n_verify_host_fn,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_check_stapled_ocsp_response(
        config: *mut s2n_config,
        check_ocsp: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_disable_x509_verification(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_max_cert_chain_depth(
        config: *mut s2n_config,
        max_depth: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_dhparams(
        config: *mut s2n_config,
        dhparams_pem: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_cipher_preferences(
        config: *mut s2n_config,
        version: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Appends the provided application protocol to the preference list"]
    #[doc = ""]
    #[doc = " The data provided in `protocol` parameter will be copied into an internal buffer"]
    #[doc = ""]
    #[doc = " @param config The configuration object being updated"]
    #[doc = " @param protocol A pointer to a byte array value"]
    #[doc = " @param protocol_len The length of bytes that should be read from `protocol`. Note: this value cannot be 0, otherwise an error will be returned."]
    pub fn s2n_config_append_protocol_preference(
        config: *mut s2n_config,
        protocol: *const u8,
        protocol_len: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_protocol_preferences(
        config: *mut s2n_config,
        protocols: *const *const ::libc::c_char,
        protocol_count: ::libc::c_int,
    ) -> ::libc::c_int;
}
pub mod s2n_status_request_type {
    pub type Type = ::libc::c_uint;
    pub const S2N_STATUS_REQUEST_NONE: Type = 0;
    pub const S2N_STATUS_REQUEST_OCSP: Type = 1;
}
extern "C" {
    pub fn s2n_config_set_status_request_type(
        config: *mut s2n_config,
        type_: s2n_status_request_type::Type,
    ) -> ::libc::c_int;
}
pub mod s2n_ct_support_level {
    pub type Type = ::libc::c_uint;
    pub const S2N_CT_SUPPORT_NONE: Type = 0;
    pub const S2N_CT_SUPPORT_REQUEST: Type = 1;
}
extern "C" {
    pub fn s2n_config_set_ct_support_level(
        config: *mut s2n_config,
        level: s2n_ct_support_level::Type,
    ) -> ::libc::c_int;
}
pub mod s2n_alert_behavior {
    pub type Type = ::libc::c_uint;
    pub const S2N_ALERT_FAIL_ON_WARNINGS: Type = 0;
    pub const S2N_ALERT_IGNORE_WARNINGS: Type = 1;
}
extern "C" {
    pub fn s2n_config_set_alert_behavior(
        config: *mut s2n_config,
        alert_behavior: s2n_alert_behavior::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_extension_data(
        config: *mut s2n_config,
        type_: s2n_tls_extension_type::Type,
        data: *const u8,
        length: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_send_max_fragment_length(
        config: *mut s2n_config,
        mfl_code: s2n_max_frag_len::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_accept_max_fragment_length(config: *mut s2n_config) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_session_state_lifetime(
        config: *mut s2n_config,
        lifetime_in_secs: u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_session_tickets_onoff(
        config: *mut s2n_config,
        enabled: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_session_cache_onoff(
        config: *mut s2n_config,
        enabled: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_ticket_encrypt_decrypt_key_lifetime(
        config: *mut s2n_config,
        lifetime_in_secs: u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_ticket_decrypt_key_lifetime(
        config: *mut s2n_config,
        lifetime_in_secs: u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_add_ticket_crypto_key(
        config: *mut s2n_config,
        name: *const u8,
        name_len: u32,
        key: *mut u8,
        key_len: u32,
        intro_time_in_seconds_from_epoch: u64,
    ) -> ::libc::c_int;
}
pub mod s2n_mode {
    pub type Type = ::libc::c_uint;
    pub const S2N_SERVER: Type = 0;
    pub const S2N_CLIENT: Type = 1;
}
extern "C" {
    pub fn s2n_connection_new(mode: s2n_mode::Type) -> *mut s2n_connection;
}
extern "C" {
    pub fn s2n_connection_set_config(
        conn: *mut s2n_connection,
        config: *mut s2n_config,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_ctx(
        conn: *mut s2n_connection,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_ctx(conn: *mut s2n_connection) -> *mut ::libc::c_void;
}
pub type s2n_client_hello_fn = ::core::option::Option<
    unsafe extern "C" fn(conn: *mut s2n_connection, ctx: *mut ::libc::c_void) -> ::libc::c_int,
>;
pub mod s2n_client_hello_cb_mode {
    pub type Type = ::libc::c_uint;
    pub const S2N_CLIENT_HELLO_CB_BLOCKING: Type = 0;
    pub const S2N_CLIENT_HELLO_CB_NONBLOCKING: Type = 1;
}
extern "C" {
    pub fn s2n_config_set_client_hello_cb(
        config: *mut s2n_config,
        client_hello_callback: s2n_client_hello_fn,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_client_hello_cb_mode(
        config: *mut s2n_config,
        cb_mode: s2n_client_hello_cb_mode::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_client_hello_cb_done(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_server_name_extension_used(conn: *mut s2n_connection) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_client_hello {
    _unused: [u8; 0],
}
extern "C" {
    pub fn s2n_connection_get_client_hello(conn: *mut s2n_connection) -> *mut s2n_client_hello;
}
extern "C" {
    pub fn s2n_client_hello_get_raw_message_length(ch: *mut s2n_client_hello) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_raw_message(
        ch: *mut s2n_client_hello,
        out: *mut u8,
        max_length: u32,
    ) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_cipher_suites_length(ch: *mut s2n_client_hello) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_cipher_suites(
        ch: *mut s2n_client_hello,
        out: *mut u8,
        max_length: u32,
    ) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_extensions_length(ch: *mut s2n_client_hello) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_extensions(
        ch: *mut s2n_client_hello,
        out: *mut u8,
        max_length: u32,
    ) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_extension_length(
        ch: *mut s2n_client_hello,
        extension_type: s2n_tls_extension_type::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_client_hello_get_extension_by_id(
        ch: *mut s2n_client_hello,
        extension_type: s2n_tls_extension_type::Type,
        out: *mut u8,
        max_length: u32,
    ) -> isize;
}
extern "C" {
    pub fn s2n_connection_set_fd(conn: *mut s2n_connection, fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_read_fd(
        conn: *mut s2n_connection,
        readfd: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_write_fd(
        conn: *mut s2n_connection,
        writefd: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_use_corked_io(conn: *mut s2n_connection) -> ::libc::c_int;
}
pub type s2n_recv_fn = ::core::option::Option<
    unsafe extern "C" fn(io_context: *mut ::libc::c_void, buf: *mut u8, len: u32) -> ::libc::c_int,
>;
pub type s2n_send_fn = ::core::option::Option<
    unsafe extern "C" fn(
        io_context: *mut ::libc::c_void,
        buf: *const u8,
        len: u32,
    ) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_connection_set_recv_ctx(
        conn: *mut s2n_connection,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_send_ctx(
        conn: *mut s2n_connection,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_recv_cb(
        conn: *mut s2n_connection,
        recv: s2n_recv_fn,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_send_cb(
        conn: *mut s2n_connection,
        send: s2n_send_fn,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_prefer_throughput(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_prefer_low_latency(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_dynamic_record_threshold(
        conn: *mut s2n_connection,
        resize_threshold: u32,
        timeout_threshold: u16,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_verify_host_callback(
        config: *mut s2n_connection,
        host_fn: s2n_verify_host_fn,
        data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
pub mod s2n_blinding {
    pub type Type = ::libc::c_uint;
    pub const S2N_BUILT_IN_BLINDING: Type = 0;
    pub const S2N_SELF_SERVICE_BLINDING: Type = 1;
}
extern "C" {
    pub fn s2n_connection_set_blinding(
        conn: *mut s2n_connection,
        blinding: s2n_blinding::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_delay(conn: *mut s2n_connection) -> u64;
}
extern "C" {
    pub fn s2n_connection_set_cipher_preferences(
        conn: *mut s2n_connection,
        version: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Appends the provided application protocol to the preference list"]
    #[doc = ""]
    #[doc = " The data provided in `protocol` parameter will be copied into an internal buffer"]
    #[doc = ""]
    #[doc = " @param conn The connection object being updated"]
    #[doc = " @param protocol A pointer to a slice of bytes"]
    #[doc = " @param protocol_len The length of bytes that should be read from `protocol`. Note: this value cannot be 0, otherwise an error will be returned."]
    pub fn s2n_connection_append_protocol_preference(
        conn: *mut s2n_connection,
        protocol: *const u8,
        protocol_len: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_protocol_preferences(
        conn: *mut s2n_connection,
        protocols: *const *const ::libc::c_char,
        protocol_count: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_set_server_name(
        conn: *mut s2n_connection,
        server_name: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_get_server_name(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_get_application_protocol(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_ocsp_response(
        conn: *mut s2n_connection,
        length: *mut u32,
    ) -> *const u8;
}
extern "C" {
    pub fn s2n_connection_get_sct_list(conn: *mut s2n_connection, length: *mut u32) -> *const u8;
}
pub mod s2n_blocked_status {
    pub type Type = ::libc::c_uint;
    pub const S2N_NOT_BLOCKED: Type = 0;
    pub const S2N_BLOCKED_ON_READ: Type = 1;
    pub const S2N_BLOCKED_ON_WRITE: Type = 2;
    pub const S2N_BLOCKED_ON_APPLICATION_INPUT: Type = 3;
    pub const S2N_BLOCKED_ON_EARLY_DATA: Type = 4;
}
extern "C" {
    pub fn s2n_negotiate(
        conn: *mut s2n_connection,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_send(
        conn: *mut s2n_connection,
        buf: *const ::libc::c_void,
        size: isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_sendv(
        conn: *mut s2n_connection,
        bufs: *const iovec,
        count: isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_sendv_with_offset(
        conn: *mut s2n_connection,
        bufs: *const iovec,
        count: isize,
        offs: isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_recv(
        conn: *mut s2n_connection,
        buf: *mut ::libc::c_void,
        size: isize,
        blocked: *mut s2n_blocked_status::Type,
    ) -> isize;
}
extern "C" {
    pub fn s2n_peek(conn: *mut s2n_connection) -> u32;
}
extern "C" {
    pub fn s2n_connection_free_handshake(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_release_buffers(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_wipe(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_free(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_shutdown(
        conn: *mut s2n_connection,
        blocked: *mut s2n_blocked_status::Type,
    ) -> ::libc::c_int;
}
pub mod s2n_cert_auth_type {
    pub type Type = ::libc::c_uint;
    pub const S2N_CERT_AUTH_NONE: Type = 0;
    pub const S2N_CERT_AUTH_REQUIRED: Type = 1;
    pub const S2N_CERT_AUTH_OPTIONAL: Type = 2;
}
extern "C" {
    pub fn s2n_config_get_client_auth_type(
        config: *mut s2n_config,
        client_auth_type: *mut s2n_cert_auth_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_set_client_auth_type(
        config: *mut s2n_config,
        client_auth_type: s2n_cert_auth_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_client_auth_type(
        conn: *mut s2n_connection,
        client_auth_type: *mut s2n_cert_auth_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_client_auth_type(
        conn: *mut s2n_connection,
        client_auth_type: s2n_cert_auth_type::Type,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_client_cert_chain(
        conn: *mut s2n_connection,
        der_cert_chain_out: *mut *mut u8,
        cert_chain_len: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_set_session(
        conn: *mut s2n_connection,
        session: *const u8,
        length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session(
        conn: *mut s2n_connection,
        session: *mut u8,
        max_length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session_ticket_lifetime_hint(
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session_length(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session_id_length(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_session_id(
        conn: *mut s2n_connection,
        session_id: *mut u8,
        max_length: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_is_session_resumed(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_is_ocsp_stapled(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_selected_cert(
        conn: *mut s2n_connection,
    ) -> *mut s2n_cert_chain_and_key;
}
extern "C" {
    #[doc = " Returns the length of the s2n certificate chain `chain_and_key`."]
    #[doc = ""]
    #[doc = " @param chain_and_key A pointer to the s2n_cert_chain_and_key object being read."]
    #[doc = " @param cert_length This return value represents the length of the s2n certificate chain `chain_and_key`."]
    pub fn s2n_cert_chain_get_length(
        chain_and_key: *const s2n_cert_chain_and_key,
        cert_length: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the certificate `out_cert` present at the index `cert_idx` of the certificate chain `chain_and_key`."]
    #[doc = ""]
    #[doc = " Note that the index of the leaf certificate is zero. If the certificate chain `chain_and_key` is NULL or the"]
    #[doc = " certificate index value is not in the acceptable range for the input certificate chain, an error is returned."]
    #[doc = ""]
    #[doc = " @param chain_and_key A pointer to the s2n_cert_chain_and_key object being read."]
    #[doc = " @param cert_idx The certificate index for the requested certificate within the s2n certificate chain."]
    #[doc = " @param cert_length This return value represents the length of the s2n certificate chain `chain_and_key`."]
    pub fn s2n_cert_chain_get_cert(
        chain_and_key: *const s2n_cert_chain_and_key,
        out_cert: *mut *mut s2n_cert,
        cert_idx: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the s2n certificate in DER format along with its length."]
    #[doc = ""]
    #[doc = " The API gets the s2n certificate `cert` in DER format. The certificate is returned in the `out_cert_der` buffer."]
    #[doc = " Here, `cert_len` represents the length of the certificate."]
    #[doc = ""]
    #[doc = " A caller can use certificate parsing tools such as the ones provided by OpenSSL to parse the DER encoded certificate chain returned."]
    #[doc = ""]
    #[doc = " # Safety"]
    #[doc = ""]
    #[doc = " The memory for the `out_cert_der` buffer is allocated and owned by s2n-tls."]
    #[doc = " Since the size of the certificate can potentially be very large, a pointer to internal connection data is returned instead of"]
    #[doc = " copying the contents into a caller-provided buffer."]
    #[doc = ""]
    #[doc = " The pointer to the output buffer `out_cert_der` is valid only while the connection exists."]
    #[doc = " The `s2n_connection_free` API frees the memory assosciated with the out_cert_der buffer and after the `s2n_connection_wipe` API is"]
    #[doc = " called the memory pointed by out_cert_der is invalid."]
    #[doc = ""]
    #[doc = " If a caller wishes to persist the `out_cert_der` beyond the lifetime of the connection, the contents would need to be"]
    #[doc = " copied prior to the connection termination."]
    #[doc = ""]
    #[doc = " @param cert A pointer to the s2n_cert object being read."]
    #[doc = " @param out_cert_der A pointer to the output buffer which will hold the s2n certificate `cert` in DER format."]
    #[doc = " @param cert_length This return value represents the length of the certificate."]
    pub fn s2n_cert_get_der(
        cert: *const s2n_cert,
        out_cert_der: *mut *const u8,
        cert_length: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the validated peer certificate chain as a `s2n_cert_chain_and_key` opaque object."]
    #[doc = ""]
    #[doc = " The `s2n_cert_chain_and_key` parameter must be allocated by the caller using the `s2n_cert_chain_and_key_new` API"]
    #[doc = " prior to this function call and must be empty. To free the memory associated with the `s2n_cert_chain_and_key` object use the"]
    #[doc = " `s2n_cert_chain_and_key_free` API."]
    #[doc = ""]
    #[doc = " @param conn A pointer to the s2n_connection object being read."]
    #[doc = " @param s2n_cert_chain_and_key The returned validated peer certificate chain `cert_chain` retrieved from the s2n connection."]
    pub fn s2n_connection_get_peer_cert_chain(
        conn: *const s2n_connection,
        cert_chain: *mut s2n_cert_chain_and_key,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the length of the DER encoded extension value of the ASN.1 X.509 certificate extension."]
    #[doc = ""]
    #[doc = " @param cert A pointer to the s2n_cert object being read."]
    #[doc = " @param oid A null-terminated cstring that contains the OID of the X.509 certificate extension to be read."]
    #[doc = " @param ext_value_len This return value contains the length of DER encoded extension value of the ASN.1 X.509 certificate extension."]
    pub fn s2n_cert_get_x509_extension_value_length(
        cert: *mut s2n_cert,
        oid: *const u8,
        ext_value_len: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the DER encoding of an ASN.1 X.509 certificate extension value, it's length and a boolean critical."]
    #[doc = ""]
    #[doc = " @param cert A pointer to the s2n_cert object being read."]
    #[doc = " @param oid A null-terminated cstring that contains the OID of the X.509 certificate extension to be read."]
    #[doc = " @param ext_value A pointer to the output buffer which will hold the DER encoding of an ASN.1 X.509 certificate extension value returned."]
    #[doc = " @param ext_value_len  This value is both an input and output parameter and represents the length of the output buffer `ext_value`."]
    #[doc = " When used as an input parameter, the caller must use this parameter to convey the maximum length of `ext_value`."]
    #[doc = " When used as an output parameter, `ext_value_len` holds the actual length of the DER encoding of the ASN.1 X.509 certificate extension value returned."]
    #[doc = " @param critical This return value contains the boolean value for `critical`."]
    pub fn s2n_cert_get_x509_extension_value(
        cert: *mut s2n_cert,
        oid: *const u8,
        ext_value: *mut u8,
        ext_value_len: *mut u32,
        critical: *mut bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the UTF8 String length of the ASN.1 X.509 certificate extension data."]
    #[doc = ""]
    #[doc = " @param extension_data A pointer to the DER encoded ASN.1 X.509 certificate extension value being read."]
    #[doc = " @param extension_len represents the length of the input buffer `extension_data`."]
    #[doc = " @param utf8_str_len This return value contains the UTF8 String length of the ASN.1 X.509 certificate extension data."]
    pub fn s2n_cert_get_utf8_string_from_extension_data_length(
        extension_data: *const u8,
        extension_len: u32,
        utf8_str_len: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Returns the UTF8 String representation of the DER encoded ASN.1 X.509 certificate extension data."]
    #[doc = ""]
    #[doc = " @param extension_data A pointer to the DER encoded ASN.1 X.509 certificate extension value being read."]
    #[doc = " @param extension_len represents the length of the input buffer `extension_data`."]
    #[doc = " @param out_data A pointer to the output buffer which will hold the UTF8 String representation of the DER encoded ASN.1 X.509"]
    #[doc = " certificate extension data returned."]
    #[doc = " @param out_len This value is both an input and output parameter and represents the length of the output buffer `out_data`."]
    #[doc = " When used as an input parameter, the caller must use this parameter to convey the maximum length of `out_data`."]
    #[doc = " When used as an output parameter, `out_len` holds the actual length of UTF8 String returned."]
    pub fn s2n_cert_get_utf8_string_from_extension_data(
        extension_data: *const u8,
        extension_len: u32,
        out_data: *mut u8,
        out_len: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_wire_bytes_in(conn: *mut s2n_connection) -> u64;
}
extern "C" {
    pub fn s2n_connection_get_wire_bytes_out(conn: *mut s2n_connection) -> u64;
}
extern "C" {
    pub fn s2n_connection_get_client_protocol_version(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_server_protocol_version(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_actual_protocol_version(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_client_hello_version(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_client_cert_used(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_cipher(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " Returns the IANA value for the connection's negotiated cipher suite."]
    #[doc = ""]
    #[doc = " The value is returned in the form of `first,second`, in order to closely match"]
    #[doc = " the values defined in the [IANA Registry](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#table-tls-parameters-4)."]
    #[doc = " For example if the connection's negotiated cipher suite is `TLS_AES_128_GCM_SHA256`,"]
    #[doc = " which is registered as `0x13,0x01`, then `first = 0x13` and `second = 0x01`."]
    #[doc = ""]
    #[doc = " This method will only succeed after the cipher suite has been negotiated with the peer."]
    #[doc = ""]
    #[doc = " @param conn A pointer to the connection being read"]
    #[doc = " @param first A pointer to a single byte, which will be updated with the first byte in the registered IANA value."]
    #[doc = " @param second A pointer to a single byte, which will be updated with the second byte in the registered IANA value."]
    #[doc = " @return A POSIX error signal. If an error was returned, the values contained in `first` and `second` should be considered invalid."]
    pub fn s2n_connection_get_cipher_iana_value(
        conn: *mut s2n_connection,
        first: *mut u8,
        second: *mut u8,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_is_valid_for_cipher_preferences(
        conn: *mut s2n_connection,
        version: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_curve(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_kem_name(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_kem_group_name(conn: *mut s2n_connection) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_alert(conn: *mut s2n_connection) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_connection_get_handshake_type_name(
        conn: *mut s2n_connection,
    ) -> *const ::libc::c_char;
}
extern "C" {
    pub fn s2n_connection_get_last_message_name(conn: *mut s2n_connection)
        -> *const ::libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s2n_async_pkey_op {
    _unused: [u8; 0],
}
pub type s2n_async_pkey_fn = ::core::option::Option<
    unsafe extern "C" fn(conn: *mut s2n_connection, op: *mut s2n_async_pkey_op) -> ::libc::c_int,
>;
extern "C" {
    pub fn s2n_config_set_async_pkey_callback(
        config: *mut s2n_config,
        fn_: s2n_async_pkey_fn,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_async_pkey_op_perform(
        op: *mut s2n_async_pkey_op,
        key: *mut s2n_cert_private_key,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_async_pkey_op_apply(
        op: *mut s2n_async_pkey_op,
        conn: *mut s2n_connection,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_async_pkey_op_free(op: *mut s2n_async_pkey_op) -> ::libc::c_int;
}
#[doc = " Callback function for handling key log events"]
#[doc = ""]
#[doc = " THIS SHOULD BE USED FOR DEBUGGING PURPOSES ONLY!"]
#[doc = ""]
#[doc = " Each log line is formatted with the"]
#[doc = " [NSS Key Log Format](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format)"]
#[doc = " without a newline."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " * `ctx` MUST be cast into the same type of pointer that was originally created"]
#[doc = " * `logline` bytes MUST be copied or discarded before this function returns"]
#[doc = ""]
#[doc = " @param ctx Context for the callback"]
#[doc = " @param conn Connection for which the log line is being emitted"]
#[doc = " @param logline Pointer to the log line data"]
#[doc = " @param len Length of the log line data"]
pub type s2n_key_log_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::libc::c_void,
        conn: *mut s2n_connection,
        logline: *mut u8,
        len: usize,
    ) -> ::libc::c_int,
>;
extern "C" {
    #[doc = " Sets a key logging callback on the provided config"]
    #[doc = ""]
    #[doc = " THIS SHOULD BE USED FOR DEBUGGING PURPOSES ONLY!"]
    #[doc = ""]
    #[doc = " Setting this function enables configurations to emit secrets in the"]
    #[doc = " [NSS Key Log Format](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format)"]
    #[doc = ""]
    #[doc = " # Safety"]
    #[doc = ""]
    #[doc = " * `callback` MUST cast `ctx` into the same type of pointer that was originally created"]
    #[doc = " * `ctx` MUST live for at least as long as it is set on the config"]
    #[doc = ""]
    #[doc = " @param config Config to set the callback"]
    #[doc = " @param callback The function that should be called for each secret log entry"]
    #[doc = " @param ctx The context to be passed when the callback is called"]
    pub fn s2n_config_set_key_log_cb(
        config: *mut s2n_config,
        callback: s2n_key_log_fn,
        ctx: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn s2n_config_enable_cert_req_dss_legacy_compat(config: *mut s2n_config) -> ::libc::c_int;
}
